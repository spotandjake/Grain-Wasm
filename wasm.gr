module Wasm

include "Bytes"
include "Int16"
include "list"
include "string"
include "runtime/numberUtils"
include "runtime/numbers"
include "runtime/dataStructures"
include "runtime/debugPrint"
include "runtime/unsafe/wasmi32"
include "runtime/unsafe/wasmi64"
include "runtime/unsafe/wasmf32"
include "runtime/unsafe/wasmf64"
from Numbers use { coerceNumberToWasmI32 }
from DataStructures use { tagInt16, newInt64, newFloat32, newFloat64 }
// Types
/**
 * Represents errors for Wasm parsing.
 */
provide enum WasmParseError {
  UnexpectedWasmToken(String),
  InvalidWasmType(Int16),
  InvalidImportDescType(Int16),
  InvalidWasmLimitType(Int16),
  InvalidWasmGlobal,
  InvalidExportDescription(Int16),
  InvalidWasmInstr(Int16),
  UnexpectedEndOfInput,
}
enum Parent {
  ParentFunction,
  ParentGlobal,
  ParentElement,
  ParentBlock,
  ParentData,
}
/**
 * Represents raw unparsed wasm sections.
 */
provide enum RawSections {
  RawCustomSection(Bytes),
  RawTypeSection(Bytes),
  RawImportSection(Bytes),
  RawFunctionSection(Bytes),
  RawTableSection(Bytes),
  RawMemorySection(Bytes),
  RawGlobalSection(Bytes),
  RawExportSection(Bytes),
  RawStartSection(Bytes),
  RawElementSection(Bytes),
  RawDataCountSection(Bytes),
  RawCodeSection(Bytes),
  RawDataSection(Bytes),
}
/**
 * Represents wasm export descriptions
 */
provide enum WasmExportDesc {
  FuncExport(Number),
  TableExport(Number),
  MemoryExport(Number),
  GlobalExport(Number),
}
/**
 * Represents wasm memory argument
 */
provide record WasmMemoryArg {
  align: Number,
  offset: Number,
}
enum WasmTypeDesc {
  AllType,
  FuncType,
  NumType,
  VecType,
  RefType,
}
/**
 * Represents wasm primitive types.
 */
provide enum WasmType {
  // FuncType
  WasmFuncType(List<WasmType>, List<WasmType>),
  // NumberType
  WasmI32,
  WasmI64,
  WasmF32,
  WasmF64,
  // VectorType
  WasmV128,
  // RefType
  WasmFuncRef,
  WasmExternRef,
  // Special
  EmptyType,
  TypeIdx(Number),
}
/**
 * Represents wasm instructions and corresponding data.
 */
provide enum WasmInstr {
  // Control Instructions
  WasmInstr_Unreachable,
  WasmInstr_Nop,
  WasmInstr_Block(WasmType, Expression),
  WasmInstr_Loop(WasmType, Expression),
  WasmInstr_If(WasmType, Expression),
  WasmInstr_If_Else(WasmType, Expression, Expression),
  WasmInstr_Br(Number),
  WasmInstr_Br_If(Number),
  WasmInstr_Br_Table(List<Number>, Number),
  WasmInstr_Return,
  WasmInstr_Call(Number),
  WasmInstr_Call_Indirect(Number, Number),
  WasmInstr_Return_Call(Number),
  WasmInstr_Return_Call_Indirect(Number, Number),
  // Reference Instructions
  WasmInstr_Ref_Null(WasmType),
  WasmInstr_Ref_Is_Null,
  WasmInstr_Ref_Func(Number),
  // Parametric Instructions
  WasmInstr_Drop,
  WasmInstr_Select(Option<List<WasmType>>),
  // Variable Instructions
  WasmInstr_Local_Get(Number),
  WasmInstr_Local_Set(Number),
  WasmInstr_Local_Tee(Number),
  WasmInstr_Global_Get(Number),
  WasmInstr_Global_Set(Number),
  // Table Instructions
  WasmInstr_Table_Get(Number),
  WasmInstr_Table_Set(Number),
  WasmInstr_Table_Init(Number, Number),
  WasmInstr_Elem_Drop(Number),
  WasmInstr_Table_Copy(Number, Number),
  WasmInstr_Table_Grow(Number),
  WasmInstr_Table_Size(Number),
  WasmInstr_Table_Fill(Number),
  // Memory Instructions
  WasmInstr_I32_Load(WasmMemoryArg),
  WasmInstr_I64_Load(WasmMemoryArg),
  WasmInstr_F32_Load(WasmMemoryArg),
  WasmInstr_F64_Load(WasmMemoryArg),
  WasmInstr_I32_Load8_S(WasmMemoryArg),
  WasmInstr_I32_Load8_U(WasmMemoryArg),
  WasmInstr_I32_Load16_S(WasmMemoryArg),
  WasmInstr_I32_Load16_U(WasmMemoryArg),
  WasmInstr_I64_Load8_S(WasmMemoryArg),
  WasmInstr_I64_Load8_U(WasmMemoryArg),
  WasmInstr_I64_Load16_S(WasmMemoryArg),
  WasmInstr_I64_Load16_U(WasmMemoryArg),
  WasmInstr_I64_Load32_S(WasmMemoryArg),
  WasmInstr_I64_Load32_U(WasmMemoryArg),
  WasmInstr_I32_Store(WasmMemoryArg),
  WasmInstr_I64_Store(WasmMemoryArg),
  WasmInstr_F32_Store(WasmMemoryArg),
  WasmInstr_F64_Store(WasmMemoryArg),
  WasmInstr_I32_Store8(WasmMemoryArg),
  WasmInstr_I32_Store16(WasmMemoryArg),
  WasmInstr_I64_Store8(WasmMemoryArg),
  WasmInstr_I64_Store16(WasmMemoryArg),
  WasmInstr_I64_Store32(WasmMemoryArg),
  WasmInstr_Memory_Size,
  WasmInstr_Memory_Grow,
  WasmInstr_Memory_Init(Number),
  WasmInstr_Data_Drop(Number),
  WasmInstr_Memory_Copy,
  WasmInstr_Memory_Fill,
  // Numeric Instructions
  WasmInstr_I32_Const(Number),
  WasmInstr_I64_Const(Number),
  WasmInstr_F32_Const(Number),
  WasmInstr_F64_Const(Number),
  WasmInstr_I32_Eqz,
  WasmInstr_I32_Eq,
  WasmInstr_I32_Ne,
  WasmInstr_I32_Lt_S,
  WasmInstr_I32_Lt_U,
  WasmInstr_I32_Gt_S,
  WasmInstr_I32_Gt_U,
  WasmInstr_I32_Le_S,
  WasmInstr_I32_Le_U,
  WasmInstr_I32_Ge_S,
  WasmInstr_I32_Ge_U,
  WasmInstr_I64_Eqz,
  WasmInstr_I64_Eq,
  WasmInstr_I64_Ne,
  WasmInstr_I64_Lt_S,
  WasmInstr_I64_Lt_U,
  WasmInstr_I64_Gt_S,
  WasmInstr_I64_Gt_U,
  WasmInstr_I64_Le_S,
  WasmInstr_I64_Le_U,
  WasmInstr_I64_Ge_S,
  WasmInstr_I64_Ge_U,
  WasmInstr_F32_Eq,
  WasmInstr_F32_Ne,
  WasmInstr_F32_Lt,
  WasmInstr_F32_Gt,
  WasmInstr_F32_Le,
  WasmInstr_F32_Ge,
  WasmInstr_F64_Eq,
  WasmInstr_F64_Ne,
  WasmInstr_F64_Lt,
  WasmInstr_F64_Gt,
  WasmInstr_F64_Le,
  WasmInstr_F64_Ge,
  WasmInstr_I32_Clz,
  WasmInstr_I32_Ctz,
  WasmInstr_I32_Popcnt,
  WasmInstr_I32_Add,
  WasmInstr_I32_Sub,
  WasmInstr_I32_Mul,
  WasmInstr_I32_Div_S,
  WasmInstr_I32_Div_U,
  WasmInstr_I32_Rem_S,
  WasmInstr_I32_Rem_U,
  WasmInstr_I32_And,
  WasmInstr_I32_Or,
  WasmInstr_I32_Xor,
  WasmInstr_I32_Shl,
  WasmInstr_I32_Shr_S,
  WasmInstr_I32_Shr_U,
  WasmInstr_I32_Rotl,
  WasmInstr_I32_Rotr,
  WasmInstr_I64_Clz,
  WasmInstr_I64_Ctz,
  WasmInstr_I64_Popcnt,
  WasmInstr_I64_Add,
  WasmInstr_I64_Sub,
  WasmInstr_I64_Mul,
  WasmInstr_I64_Div_S,
  WasmInstr_I64_Div_U,
  WasmInstr_I64_Rem_S,
  WasmInstr_I64_Rem_U,
  WasmInstr_I64_And,
  WasmInstr_I64_Or,
  WasmInstr_I64_Xor,
  WasmInstr_I64_Shl,
  WasmInstr_I64_Shr_S,
  WasmInstr_I64_Shr_U,
  WasmInstr_I64_Rotl,
  WasmInstr_I64_Rotr,
  WasmInstr_F32_Abs,
  WasmInstr_F32_Neg,
  WasmInstr_F32_Ceil,
  WasmInstr_F32_Floor,
  WasmInstr_F32_Trunc,
  WasmInstr_F32_Nearest,
  WasmInstr_F32_Sqrt,
  WasmInstr_F32_Add,
  WasmInstr_F32_Sub,
  WasmInstr_F32_Mul,
  WasmInstr_F32_Div,
  WasmInstr_F32_Min,
  WasmInstr_F32_Max,
  WasmInstr_F32_CopySign,
  WasmInstr_F64_Abs,
  WasmInstr_F64_Neg,
  WasmInstr_F64_Ceil,
  WasmInstr_F64_Floor,
  WasmInstr_F64_Trunc,
  WasmInstr_F64_Nearest,
  WasmInstr_F64_Sqrt,
  WasmInstr_F64_Add,
  WasmInstr_F64_Sub,
  WasmInstr_F64_Mul,
  WasmInstr_F64_Div,
  WasmInstr_F64_Min,
  WasmInstr_F64_Max,
  WasmInstr_F64_CopySign,
  WasmInstr_I32_Wrap_I64,
  WasmInstr_I32_Trunc_F32_S,
  WasmInstr_I32_Trunc_F32_U,
  WasmInstr_I32_Trunc_F64_S,
  WasmInstr_I32_Trunc_F64_U,
  WasmInstr_I64_Extend_I32_S,
  WasmInstr_I64_Extend_I32_U,
  WasmInstr_I64_Trunc_F32_S,
  WasmInstr_I64_Trunc_F32_U,
  WasmInstr_I64_Trunc_F64_S,
  WasmInstr_I64_Trunc_F64_U,
  WasmInstr_F32_Convert_I32_S,
  WasmInstr_F32_Convert_I32_U,
  WasmInstr_F32_Convert_I64_S,
  WasmInstr_F32_Convert_I64_U,
  WasmInstr_F32_Demote_F64,
  WasmInstr_F64_Convert_I32_S,
  WasmInstr_F64_Convert_I32_U,
  WasmInstr_F64_Convert_I64_S,
  WasmInstr_F64_Convert_I64_U,
  WasmInstr_F64_Promote_F32,
  WasmInstr_I32_Reinterpret_F32,
  WasmInstr_I64_Reinterpret_F64,
  WasmInstr_F32_Reinterpret_I32,
  WasmInstr_F64_Reinterpret_I64,
  WasmInstr_I32_Extend8_S,
  WasmInstr_I32_Extend16_S,
  WasmInstr_I64_Extend8_S,
  WasmInstr_I64_Extend16_S,
  WasmInstr_I64_Extend32_S,
  WasmInstr_I32_TruncSat_F32_S,
  WasmInstr_I32_TruncSat_F32_U,
  WasmInstr_I32_TruncSat_F64_S,
  WasmInstr_I32_TruncSat_F64_U,
  WasmInstr_I64_TruncSat_F32_S,
  WasmInstr_I64_TruncSat_F32_U,
  WasmInstr_I64_TruncSat_F64_S,
  WasmInstr_I64_TruncSat_F64_U,
  // Vector Instructions
  WasmInstr_V128_Load(WasmMemoryArg),
  WasmInstr_V128_8x8_Load_S(WasmMemoryArg),
  WasmInstr_V128_8x8_Load_U(WasmMemoryArg),
  WasmInstr_V128_16x4_Load_S(WasmMemoryArg),
  WasmInstr_V128_16x4_Load_U(WasmMemoryArg),
  WasmInstr_V128_32x2_Load_S(WasmMemoryArg),
  WasmInstr_V128_32x2_Load_U(WasmMemoryArg),
  WasmInstr_V128_Load_8_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_16_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_32_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_64_Splat(WasmMemoryArg),
  WasmInstr_Load_32_Zero(WasmMemoryArg),
  WasmInstr_Load_64_Zero(WasmMemoryArg),
  WasmInstr_V128_Store(WasmMemoryArg),
  WasmInstr_V128_Load8_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load16_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load32_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load64_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store8_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store16_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store32_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store64_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Const(Number),
  WasmInstr_I8x16_Shuffle(Number),
  WasmInstr_I8x16_Extract_Lane_S(Number),
  WasmInstr_I8x16_Extract_Lane_U(Number),
  WasmInstr_I8x16_Replace_Lane(Number),
  WasmInstr_I16x8_Extract_Lane_S(Number),
  WasmInstr_I16x8_Extract_Lane_U(Number),
  WasmInstr_I16x8_Replace_Lane(Number),
  WasmInstr_I32x4_Extract_Lane(Number),
  WasmInstr_I32x4_Replace_Lane(Number),
  WasmInstr_I64x2_Extract_Lane(Number),
  WasmInstr_I64x2_Replace_Lane(Number),
  WasmInstr_F32x4_Extract_Lane(Number),
  WasmInstr_F32x4_Replace_Lane(Number),
  WasmInstr_F64x2_Extract_Lane(Number),
  WasmInstr_F64x2_Replace_Lane(Number),
  WasmInstr_I8x16_Swizzle,
  WasmInstr_I8x16_Splat,
  WasmInstr_I16x8_Splat,
  WasmInstr_I32x4_Splat,
  WasmInstr_I64x2_Splat,
  WasmInstr_F32x4_Splat,
  WasmInstr_F64x2_Splat,
  WasmInstr_I8x16_Eq,
  WasmInstr_I8x16_Ne,
  WasmInstr_I8x16_Lt_S,
  WasmInstr_I8x16_Lt_U,
  WasmInstr_I8x16_Gt_S,
  WasmInstr_I8x16_Gt_U,
  WasmInstr_I8x16_Le_S,
  WasmInstr_I8x16_Le_U,
  WasmInstr_I8x16_Ge_S,
  WasmInstr_I8x16_Ge_U,
  WasmInstr_I16x8_Eq,
  WasmInstr_I16x8_Ne,
  WasmInstr_I16x8_Lt_S,
  WasmInstr_I16x8_Lt_U,
  WasmInstr_I16x8_Gt_S,
  WasmInstr_I16x8_Gt_U,
  WasmInstr_I16x8_Le_S,
  WasmInstr_I16x8_Le_U,
  WasmInstr_I16x8_Ge_S,
  WasmInstr_I16x8_Ge_U,
  WasmInstr_I32x4_Eq,
  WasmInstr_I32x4_Ne,
  WasmInstr_I32x4_Lt_S,
  WasmInstr_I32x4_Lt_U,
  WasmInstr_I32x4_Gt_S,
  WasmInstr_I32x4_Gt_U,
  WasmInstr_I32x4_Le_S,
  WasmInstr_I32x4_Le_U,
  WasmInstr_I32x4_Ge_S,
  WasmInstr_I32x4_Ge_U,
  WasmInstr_I64x2_Eq,
  WasmInstr_I64x2_Ne,
  WasmInstr_I64x2_Lt_S,
  WasmInstr_I64x2_Gt_S,
  WasmInstr_I64x2_Le_S,
  WasmInstr_I64x2_Ge_S,
  WasmInstr_F32x4_Eq,
  WasmInstr_F32x4_Ne,
  WasmInstr_F32x4_Lt,
  WasmInstr_F32x4_Gt,
  WasmInstr_F32x4_Le,
  WasmInstr_F32x4_Ge,
  WasmInstr_F64x2_Eq,
  WasmInstr_F64x2_Ne,
  WasmInstr_F64x2_Lt,
  WasmInstr_F64x2_Gt,
  WasmInstr_F64x2_Le,
  WasmInstr_F64x2_Ge,
  WasmInstr_V128_Not,
  WasmInstr_V128_And,
  WasmInstr_V128_And_Not,
  WasmInstr_V128_Or,
  WasmInstr_V128_Xor,
  WasmInstr_V128_Bitselect,
  WasmInstr_V128_Any_True,
  WasmInstr_I8x16_Abs,
  WasmInstr_I8x16_Neg,
  WasmInstr_I8x16_Popcnt,
  WasmInstr_I8x16_All_True,
  WasmInstr_I8x16_Bitmask,
  WasmInstr_I8x16_Narrow_I16x8_S,
  WasmInstr_I8x16_Narrow_I16x8_U,
  WasmInstr_I8x16_Shl,
  WasmInstr_I8x16_Shr_S,
  WasmInstr_I8x16_Shr_U,
  WasmInstr_I8x16_Add,
  WasmInstr_I8x16_Add_Sat_S,
  WasmInstr_I8x16_Add_Sat_U,
  WasmInstr_I8x16_Sub,
  WasmInstr_I8x16_Sub_Sat_S,
  WasmInstr_I8x16_Sub_Sat_U,
  WasmInstr_I8x16_Min_S,
  WasmInstr_I8x16_Min_U,
  WasmInstr_I8x16_Max_S,
  WasmInstr_I8x16_Max_U,
  WasmInstr_I8x16_Avgr_U,
  WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_S,
  WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_U,
  WasmInstr_I16x8_Abs,
  WasmInstr_I16x8_Neg,
  WasmInstr_I16x8_q15mulr_sat_s,
  WasmInstr_I16x8_All_True,
  WasmInstr_I16x8_Bitmask,
  WasmInstr_I16x8_Narrow_I32x4_S,
  WasmInstr_I16x8_Narrow_I32x4_U,
  WasmInstr_I16x8_Extend_Low_I8x16_S,
  WasmInstr_I16x8_Extend_High_I8x16_S,
  WasmInstr_I16x8_Extend_Low_I8x16_U,
  WasmInstr_I16x8_Extend_High_I8x16_U,
  WasmInstr_I16x8_Shl,
  WasmInstr_I16x8_Shr_S,
  WasmInstr_I16x8_Shr_U,
  WasmInstr_I16x8_Add,
  WasmInstr_I16x8_Add_Sat_S,
  WasmInstr_I16x8_Add_Sat_U,
  WasmInstr_I16x8_Sub,
  WasmInstr_I16x8_Sub_Sat_S,
  WasmInstr_I16x8_Sub_Sat_U,
  WasmInstr_I16x8_Mul,
  WasmInstr_I16x8_Min_S,
  WasmInstr_I16x8_Min_U,
  WasmInstr_I16x8_Max_S,
  WasmInstr_I16x8_Max_U,
  WasmInstr_I16x8_Avgr_U,
  WasmInstr_I16x8_ExtMulLow_I8x16_S,
  WasmInstr_I16x8_ExtMulHigh_I8x16_S,
  WasmInstr_I16x8_ExtMulLow_I8x16_U,
  WasmInstr_I16x8_ExtMulHigh_I8x16_U,
  WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_S,
  WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_U,
  WasmInstr_I32x4_Abs,
  WasmInstr_I32x4_Neg,
  WasmInstr_I32x4_All_True,
  WasmInstr_I32x4_Bitmask,
  WasmInstr_I32x4_Extend_Low_I16x8_S,
  WasmInstr_I32x4_Extend_High_I16x8_S,
  WasmInstr_I32x4_Extend_Low_I16x8_U,
  WasmInstr_I32x4_Extend_High_I16x8_U,
  WasmInstr_I32x4_Shl,
  WasmInstr_I32x4_Shr_S,
  WasmInstr_I32x4_Shr_U,
  WasmInstr_I32x4_Add,
  WasmInstr_I32x4_Sub,
  WasmInstr_I32x4_Mul,
  WasmInstr_I32x4_Min_S,
  WasmInstr_I32x4_Min_U,
  WasmInstr_I32x4_Max_S,
  WasmInstr_I32x4_Max_U,
  WasmInstr_I32x4_Dot_I16x8_S,
  WasmInstr_I32x4_ExtMulLow_I16x8_S,
  WasmInstr_I32x4_ExtMulHigh_I16x8_S,
  WasmInstr_I32x4_ExtMulLow_I16x8_U,
  WasmInstr_I32x4_ExtMulHigh_I16x8_U,
  WasmInstr_I64x2_Abs,
  WasmInstr_I64x2_Neg,
  WasmInstr_I64x2_All_True,
  WasmInstr_I64x2_Bitmask,
  WasmInstr_I64x2_Extend_Low_I32x4_S,
  WasmInstr_I64x2_Extend_High_I32x4_S,
  WasmInstr_I64x2_Extend_Low_I32x4_U,
  WasmInstr_I64x2_Extend_High_I32x4_U,
  WasmInstr_I64x2_Shl,
  WasmInstr_I64x2_Shr_S,
  WasmInstr_I64x2_Shr_U,
  WasmInstr_I64x2_Add,
  WasmInstr_I64x2_Sub,
  WasmInstr_I64x2_Mul,
  WasmInstr_I64x2_ExtMulLow_I32x4_S,
  WasmInstr_I64x2_ExtMulHigh_I32x4_S,
  WasmInstr_I64x2_ExtMulLow_I32x4_U,
  WasmInstr_I64x2_ExtMulHigh_I32x4_U,
  WasmInstr_F32x4_Ceil,
  WasmInstr_F32x4_Floor,
  WasmInstr_F32x4_Trunc,
  WasmInstr_F32x4_Nearest,
  WasmInstr_F32x4_Abs,
  WasmInstr_F32x4_Neg,
  WasmInstr_F32x4_Sqrt,
  WasmInstr_F32x4_Add,
  WasmInstr_F32x4_Sub,
  WasmInstr_F32x4_Mul,
  WasmInstr_F32x4_Div,
  WasmInstr_F32x4_Min,
  WasmInstr_F32x4_Max,
  WasmInstr_F32x4_Pmin,
  WasmInstr_F32x4_Pmax,
  WasmInstr_F64x2_Ceil,
  WasmInstr_F64x2_Floor,
  WasmInstr_F64x2_Trunc,
  WasmInstr_F64x2_Nearest,
  WasmInstr_F64x2_Abs,
  WasmInstr_F64x2_Neg,
  WasmInstr_F64x2_Sqrt,
  WasmInstr_F64x2_Add,
  WasmInstr_F64x2_Sub,
  WasmInstr_F64x2_Mul,
  WasmInstr_F64x2_Div,
  WasmInstr_F64x2_Min,
  WasmInstr_F64x2_Max,
  WasmInstr_F64x2_Pmin,
  WasmInstr_F64x2_Pmax,
  WasmInstr_I32x4_Trunc_Sat_F32x4_S,
  WasmInstr_I32x4_Trunc_Sat_F32x4_U,
  WasmInstr_F32x4_Convert_I32x4_S,
  WasmInstr_F32x4_Convert_I32x4_U,
  WasmInstr_I32x4_Trunc_Sat_F64x2_S_Zero,
  WasmInstr_I32x4_Trunc_Sat_F64x2_U_Zero,
  WasmInstr_F64x2_ConvertLow_I32x4_S,
  WasmInstr_F64x2_ConvertLow_I32x4_U,
  WasmInstr_F32x4_Demote_F64x2_Zero,
  WasmInstr_F64x2_PromoteLow_F32x4,
  // End
  WasmInstr_Else,
  WasmInstr_End,
},
/**
 * Represents a wasm expression
 */
provide type Expression = List<WasmInstr>
/**
 * Represents a wasm table.
 */
provide record WasmTableType {
  wasmType: WasmType,
  minLimit: Number,
  maxLimit: Option<Number>,
}
/**
 * Represents a wasm global.
 */
provide record WasmGlobalType {
  wasmType: WasmType,
  isMutable: Bool,
}
/**
 * Represents a wasm export.
 */
provide record WasmExportType {
  name: String,
  exportDesc: WasmExportDesc,
}
/**
 * Represents a wasm local.
 */
provide record WasmLocalType {
  wasmType: WasmType,
  count: Number,
}
/**
 * Represents a wasm function.
 */
provide record WasmFunctionType {
  locals: List<WasmLocalType>,
  body: Expression,
}
/**
 * Represents a wasm elements mode.
 */
provide enum WasmElemMode {
  ElemPassive,
  ElemActive{
    tableIdx: Number,
    offset: Expression,
  },
  ElemDeclarative,
}
/**
 * Represents a wasm element segment.
 */
provide record WasmElementSegment {
  wasmType: WasmType,
  contents: List<Expression>,
  elemMode: WasmElemMode,
}
/**
 * Represents a wasm data segment.
 */
provide enum WasmDataSegment {
  DataActive{
    memIdx: Number,
    offset: Expression,
    content: Bytes,
  },
  DataPassive{
    content: Bytes,
  },
}
/**
 * Represents a wasm import description.
 */
provide enum WasmImportDesc {
  WasmFuncImportDesc(Number),
  WasmTableImportDesc(WasmTableType),
  WasmMemoryImportDesc(Number, Option<Number>),
  WasmGlobalImportDesc(WasmGlobalType),
}
/**
 * Represents a wasm import.
 */
provide record WasmImport {
  importModName: String,
  importName: String,
  importDesc: WasmImportDesc,
}
/**
 * Represents parsed wasm sections.
 */
provide enum Sections {
  CustomSection(Bytes),
  TypeSection(List<WasmType>),
  ImportSection(List<WasmImport>),
  FunctionSection(List<Number>),
  TableSection(List<WasmTableType>),
  MemorySection(List<(Number, Option<Number>)>),
  GlobalSection(List<(WasmGlobalType, Expression)>),
  ExportSection(List<WasmExportType>),
  StartSection(Number),
  ElementSection(List<WasmElementSegment>),
  DataCountSection(Number),
  CodeSection(List<WasmFunctionType>),
  DataSection(List<WasmDataSegment>),
}
// Helpers
record WasmParserState {
  bytes: Bytes,
  mut currentByte: Int16,
  mut pos: Number,
}
let _END_OF_INPUT = -1S
// Errors
@unsafe
let toHex = (n: Number) => {
  let x = coerceNumberToWasmI32(n)
  NumberUtils.itoa32(x, 16n)
}
let toHexWithZeroPadding = (n: Number, padTo: Number) => {
  // Note that this function is only called in exceptional cases so no effort
  // was made to optimize it.
  let mut result = toHex(n)
  while (String.length(result) < padTo) {
    result = "0" ++ result
  }
  result
}
let formatByteOrEOL = byte => {
  if (byte == _END_OF_INPUT) "End Of Input"
  else "0x" ++
    toHex(Int16.toNumber(byte))
}
let buildUnexpectedWasmToken =
  (
    parserState: WasmParserState,
    expected: Int16,
    found: Int16,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      formatByteOrEOL(expected) ++
      ", found: " ++
      formatByteOrEOL(found)
    )
  )
}
let buildUnexpectedWasmTokenCustom =
  (
    parserState: WasmParserState,
    expected: String,
    found: String,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      expected ++
      ", found: " ++
      found
    )
  )
}
// Streaming
@unsafe
let _INT8_BYTE_SIZE = 1n
@unsafe
let _FLOAT32_BYTE_SIZE = 4n
@unsafe
let _FLOAT64_BYTE_SIZE = 8n
@unsafe
let _SIZE_OFFSET = 4n
@unsafe
let _VALUE_OFFSET = 8n
let isAtEndOfInput = parserState => {
  parserState.currentByte == _END_OF_INPUT
}
@unsafe
let readByte = (idx: Number, bytes: Bytes) => {
  from WasmI32 use { add as (+), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(idx)
  if (offset + _INT8_BYTE_SIZE > size) {
    _END_OF_INPUT
  } else {
    let n = WasmI32.load8U(ptr + offset, _VALUE_OFFSET)
    tagInt16(n)
  }
}
/**
 * Reads the next byte from the parser state.
 *
 * This uses Int16 over Int8 or Uint8 because we want to support -1 for end of input, but we need to support the entire range of Uint8
 */
let nextByteU = parserState => {
  let mut c = parserState.currentByte
  if (c != _END_OF_INPUT) {
    c = readByte(parserState.pos, parserState.bytes)
    parserState.currentByte = c
    parserState.pos += 1
  }
  c
}
@unsafe
let nextF32 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 4
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { add as (+), sub as (-), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 4n
  if (offset + _FLOAT32_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let n = WasmF32.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat32(n)): Number)
  }
}
@unsafe
let nextF64 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 8
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { add as (+), sub as (-), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 8n
  if (offset + _FLOAT64_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float64
    let n = WasmF64.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat64(n)): Number)
  }
}
@unsafe
let nextI128 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 16
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { add as (+), sub as (-), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 16n
  if (offset + _FLOAT64_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let lower = WasmI64.load(ptr + offset, _VALUE_OFFSET)
    let upper = WasmI64.load(ptr + offset + 8n, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Build our Number
    let lower = WasmI32.toGrain(newInt64(lower)): Number
    let upper = WasmI32.toGrain(newInt64(upper)): Number
    // TODO: Verify all this logic works
    let n = lower | upper << 64
    // Return
    Ok(n)
  }
}

let getUleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    result = result | (byte & 0x7f) << shift
    nextByteU(parserState)
    if ((0x80 & byte) == 0) break
    shift += 7
  }
  // Return Result
  result
}
let getleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    nextByteU(parserState)
    result = result | (byte & 0x7f) << shift
    shift += 7
    if ((0x80 & byte) == 0) {
      if (shift < 32 && (byte & 0x40) != 0) {
        result = result | -1 << shift
      }
      break
    }
  }
  // Return Result
  result
}
let getStringAndAdvance = parserState => {
  // TODO: Optimize this using unsafe
  // Get String Length
  let stringLen = getUleb128AndAdvance(parserState, 32)
  // Get The String
  let str = Bytes.slice(parserState.pos - 1, stringLen, parserState.bytes)
  let str = Bytes.toString(str)
  parserState.pos += stringLen - 1
  // Return The String
  str
}
let expectByteAndAdvance =
  (
    expectedByte: Int16,
    parserState: WasmParserState,
  ) => {
  let c = parserState.currentByte
  if (c == expectedByte) {
    nextByteU(parserState)
    None
  } else {
    Some(buildUnexpectedWasmToken(parserState, expectedByte, c))
  }
}
let makeParser = bytes => {
  let parserState = {
    bytes,
    currentByte: readByte(0, bytes),
    pos: 1,
  }: WasmParserState
  parserState
}
let saveParser = parserState => (parserState.pos, parserState.currentByte)
let loadParser = (parserState, (pos, currentByte)) => {
  parserState.pos = pos
  parserState.currentByte = currentByte
}
// Parser
/**
 * Wasm Parsing Utils.
 */
provide module Parser {
  /**
   * Parse a wasm binary into unparsed sections.
   *
   * @param rawBytes: The wasm binary to parse
   *
   * @returns The unparsed sections
   */

  provide let parseModule = rawBytes => {
    // Build Our Parser State
    let parserState = makeParser(rawBytes)
    // Check For Magic Number
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x61S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x73S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x6dS, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Check For Version
    match (expectByteAndAdvance(0x01S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse Sections
    let mut wasmFile = []
    while (!isAtEndOfInput(parserState)) {
      let sectionID = parserState.currentByte
      nextByteU(parserState)
      // Validate SectionID
      let sectionLen = getUleb128AndAdvance(parserState, 32)
      // Collect Data
      let sectionContent = Bytes.slice(
        parserState.pos - 1,
        sectionLen,
        parserState.bytes
      )
      parserState.pos += sectionLen - 1
      nextByteU(parserState)
      // Collect The Bytes Object We Need
      wasmFile = match (sectionID) {
        0S => [RawCustomSection(sectionContent), ...wasmFile],
        1S => [RawTypeSection(sectionContent), ...wasmFile],
        2S => [RawImportSection(sectionContent), ...wasmFile],
        3S => [RawFunctionSection(sectionContent), ...wasmFile],
        4S => [RawTableSection(sectionContent), ...wasmFile],
        5S => [RawMemorySection(sectionContent), ...wasmFile],
        6S => [RawGlobalSection(sectionContent), ...wasmFile],
        7S => [RawExportSection(sectionContent), ...wasmFile],
        8S => [RawStartSection(sectionContent), ...wasmFile],
        9S => [RawElementSection(sectionContent), ...wasmFile],
        10S => [RawCodeSection(sectionContent), ...wasmFile],
        11S => [RawDataSection(sectionContent), ...wasmFile],
        12S => [RawDataCountSection(sectionContent), ...wasmFile],
        _ => {
          return buildUnexpectedWasmTokenCustom(
            parserState,
            "0-12",
            toString(sectionID)
          )
        },
      }
    }
    // Return
    return Ok(List.reverse(wasmFile))
  }
  // Parse Section
  let parseLimits = parserState => {
    let limitType = parserState.currentByte
    nextByteU(parserState)
    let minLimit = getUleb128AndAdvance(parserState, 32)
    let maxLimit = match (limitType) {
      0x00S => None,
      0x01S => Some(getUleb128AndAdvance(parserState, 32)),
      _ => return Err(InvalidWasmLimitType(limitType)),
    }
    return Ok((minLimit, maxLimit))
  }
  let parseWasmKind = parserState => {
    let wasmType = match (parserState.currentByte) {
      0x00S => Ok(WasmFuncRef),
      // Unknown Type
      c => Err(InvalidWasmType(c)),
    }
    nextByteU(parserState)
    wasmType
  }
  let parseWasmType = (parserState, typeFilter=AllType) => {
    let wasmType = match (parserState.currentByte) {
      // NumType
      0x7fS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI32),
      0x7eS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI64),
      0x7dS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF32),
      0x7cS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF64),
      // VecType
      0x7BS when typeFilter == AllType || typeFilter == VecType => Ok(WasmV128),
      // RefType
      0x70S when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmFuncRef),
      0x6fS when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmExternRef),
      // Unknown Type
      c => Err(InvalidWasmType(c)),
    }
    nextByteU(parserState)
    wasmType
  }
  let parseFunctionType = parserState => {
    // Expect The Function Start Type
    match (expectByteAndAdvance(0x60S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse The Params
    let paramCount = getUleb128AndAdvance(parserState, 32)
    let mut params = []
    for (let mut i = 0; i < paramCount; i += 1) {
      let paramType = parseWasmType(parserState, typeFilter=NumType)
      match (paramType) {
        Ok(paramType) => {
          params = [paramType, ...params]
        },
        Err(err) => return Err(err),
      }
    }
    // Parse The Result
    let resultCount = getUleb128AndAdvance(parserState, 32)
    let mut results = []
    for (let mut i = 0; i < resultCount; i += 1) {
      let resultType = parseWasmType(parserState, typeFilter=NumType)
      match (resultType) {
        Ok(resultType) => {
          results = [resultType, ...results]
        },
        Err(err) => return Err(err),
      }
    }
    // Return
    return Ok(WasmFuncType(List.reverse(params), List.reverse(results)))
  }
  let parseTableType = parserState => {
    let tableType = match (parseWasmType(parserState, typeFilter=RefType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let (minLimit, maxLimit) = match (parseLimits(parserState)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    return Ok({ wasmType: tableType, minLimit, maxLimit }: WasmTableType)
  }
  let parseGlobalType = parserState => {
    let valType = match (parseWasmType(parserState, typeFilter=NumType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let mutable = match (parserState.currentByte) {
      0x00S => false,
      0x01S => true,
      _ => return Err(InvalidWasmGlobal),
    }
    nextByteU(parserState)
    return Ok({ wasmType: valType, isMutable: mutable }: WasmGlobalType)
  }
  let parseWasmImport = parserState => {
    let importModName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importDescType = parserState.currentByte
    nextByteU(parserState)
    // Parse The Import Description
    let importDesc = match (importDescType) {
      0x00S => {
        let typeID = getUleb128AndAdvance(parserState, 32)
        WasmFuncImportDesc(typeID)
      },
      0x01S => {
        let tableType = match (parseTableType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmTableImportDesc(tableType)
      },
      0x02S => {
        let (minLimit, maxLimit) = match (parseLimits(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmMemoryImportDesc(minLimit, maxLimit)
      },
      0x03S => {
        let globalType = match (parseGlobalType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmGlobalImportDesc(globalType)
      },
      _ => return Err(InvalidImportDescType(importDescType)),
    }
    // Return The Import
    return Ok({ importModName, importName, importDesc }: WasmImport)
  }
  let parseBlockType = parserState => {
    match (parserState.currentByte) {
      0x40S => {
        nextByteU(parserState)
        return Ok(EmptyType)
      },
      _ => {
        let savePoint = saveParser(parserState)
        let wasmType = match (parseWasmType(parserState, typeFilter=NumType)) {
          Ok(t) => Ok(t),
          Err(e) => {
            loadParser(parserState, savePoint)
            let typeIdx = getleb128AndAdvance(parserState, 33)
            // TODO: I think this requires special logic because its signed and 33 bit so it wont map properly to our type IDX
            Ok(TypeIdx(typeIdx))
          },
        }
        return wasmType
      },
    }
  }
  let parseMemArg = parserState => {
    let align = getUleb128AndAdvance(parserState, 32)
    let offset = getUleb128AndAdvance(parserState, 32)
    return { align, offset }: WasmMemoryArg
  }
  let rec parseInstr = parserState => {
    let c = parserState.currentByte
    nextByteU(parserState)
    return match (c) {
      // Control Expression
      0x00S => Ok(WasmInstr_Unreachable),
      0x01S => Ok(WasmInstr_Nop),
      0x02S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstr_Block(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x03S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstr_Loop(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x04S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        // Parse If
        let mut ifSection = []
        let mut hasElse = false
        while (!isAtEndOfInput(parserState)) {
          let instr = parseInstr(parserState)
          match (instr) {
            Ok(instr) => {
              ifSection = [instr, ...ifSection]
              if (instr == WasmInstr_Else) hasElse = true
              if (instr == WasmInstr_Else || instr == WasmInstr_End) break
            },
            Err(err) => return Err(err),
          }
        }
        match (hasElse) {
          true => {
            let elseSection = parseExpr(parserState, ParentBlock)
            match (elseSection) {
              Ok(elseSection) =>
                Ok(WasmInstr_If_Else(blockType, ifSection, elseSection)),
              Err(err) => return Err(err),
            }
          },
          false => Ok(WasmInstr_If(blockType, ifSection)),
        }
      },
      0x0CS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br(labelIdx))
      },
      0x0DS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br_If(labelIdx))
      },
      0x0ES => {
        let labelCount = getUleb128AndAdvance(parserState, 32)
        let mut labelIdxs = []
        for (let mut i = 0; i < labelCount; i += 1) {
          let labelIdx = getUleb128AndAdvance(parserState, 32)
          labelIdxs = [labelIdx, ...labelIdxs]
        }
        let defaultLabel = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br_Table(List.reverse(labelIdxs), defaultLabel))
      },
      0x0FS => Ok(WasmInstr_Return),
      0x10S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Call(funcIdx))
      },
      0x11S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Call_Indirect(typeIdx, tableIdx))
      },
      0x12S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Return_Call(funcIdx))
      },
      0x13S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Return_Call_Indirect(typeIdx, tableIdx))
      },
      // Reference Instructions
      0xD0S => {
        let refType = match (parseWasmType(parserState, typeFilter=RefType)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_Ref_Null(refType))
      },
      0xD1S => Ok(WasmInstr_Ref_Is_Null),
      0xD2S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Ref_Func(funcIdx))
      },
      // Parametric Instructions
      0x1AS => Ok(WasmInstr_Drop),
      0x1BS => Ok(WasmInstr_Select(None)),
      0x1CS => {
        let typeCount = getUleb128AndAdvance(parserState, 32)
        let mut types = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let wasmType = match (parseWasmType(
            parserState,
            typeFilter=NumType
          )) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          types = [wasmType, ...types]
        }
        Ok(WasmInstr_Select(Some(List.reverse(types))))
      },
      // Variable Instructions
      0x20S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Get(localIdx))
      },
      0x21S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Set(localIdx))
      },
      0x22S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Tee(localIdx))
      },
      0x23S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Global_Get(globalIdx))
      },
      0x24S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Global_Set(globalIdx))
      },
      // Table Instructions
      0x25S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Table_Get(tableIdx))
      },
      0x26S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Table_Set(tableIdx))
      },
      // Memory Instructions
      0x28S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load(memArg))
      },
      0x29S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load(memArg))
      },
      0x2AS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F32_Load(memArg))
      },
      0x2BS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F64_Load(memArg))
      },
      0x2CS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load8_S(memArg))
      },
      0x2DS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load8_U(memArg))
      },
      0x2ES => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load16_S(memArg))
      },
      0x2FS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load16_U(memArg))
      },
      0x30S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load8_S(memArg))
      },
      0x31S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load8_U(memArg))
      },
      0x32S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load16_S(memArg))
      },
      0x33S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load16_U(memArg))
      },
      0x34S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load32_S(memArg))
      },
      0x35S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load32_U(memArg))
      },
      0x36S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store(memArg))
      },
      0x37S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store(memArg))
      },
      0x38S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F32_Store(memArg))
      },
      0x39S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F64_Store(memArg))
      },
      0x3AS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store8(memArg))
      },
      0x3BS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store16(memArg))
      },
      0x3CS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store8(memArg))
      },
      0x3DS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store16(memArg))
      },
      0x3ES => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store32(memArg))
      },
      0x3FS => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstr_Memory_Size)
      },
      0x40S => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstr_Memory_Grow)
      },
      // Numeric Instructions
      0x41S => {
        let value = getleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_I32_Const(value))
      },
      0x42S => {
        let value = getleb128AndAdvance(parserState, 64)
        Ok(WasmInstr_I64_Const(value))
      },
      0x43S => {
        let value = match (nextF32(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_F32_Const(value))
      },
      0x44S => {
        let value = match (nextF64(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_F64_Const(value))
      },
      0x45S => Ok(WasmInstr_I32_Eqz),
      0x46S => Ok(WasmInstr_I32_Eq),
      0x47S => Ok(WasmInstr_I32_Ne),
      0x48S => Ok(WasmInstr_I32_Lt_S),
      0x49S => Ok(WasmInstr_I32_Lt_U),
      0x4AS => Ok(WasmInstr_I32_Gt_S),
      0x4BS => Ok(WasmInstr_I32_Gt_U),
      0x4CS => Ok(WasmInstr_I32_Le_S),
      0x4DS => Ok(WasmInstr_I32_Le_U),
      0x4ES => Ok(WasmInstr_I32_Ge_S),
      0x4FS => Ok(WasmInstr_I32_Ge_U),
      0x50S => Ok(WasmInstr_I64_Eqz),
      0x51S => Ok(WasmInstr_I64_Eq),
      0x52S => Ok(WasmInstr_I64_Ne),
      0x53S => Ok(WasmInstr_I64_Lt_S),
      0x54S => Ok(WasmInstr_I64_Lt_U),
      0x55S => Ok(WasmInstr_I64_Gt_S),
      0x56S => Ok(WasmInstr_I64_Gt_U),
      0x57S => Ok(WasmInstr_I64_Le_S),
      0x58S => Ok(WasmInstr_I64_Le_U),
      0x59S => Ok(WasmInstr_I64_Ge_S),
      0x5AS => Ok(WasmInstr_I64_Ge_U),
      0x5BS => Ok(WasmInstr_F32_Eq),
      0x5CS => Ok(WasmInstr_F32_Ne),
      0x5DS => Ok(WasmInstr_F32_Lt),
      0x5ES => Ok(WasmInstr_F32_Gt),
      0x5FS => Ok(WasmInstr_F32_Le),
      0x60S => Ok(WasmInstr_F32_Ge),
      0x61S => Ok(WasmInstr_F64_Eq),
      0x62S => Ok(WasmInstr_F64_Ne),
      0x63S => Ok(WasmInstr_F64_Lt),
      0x64S => Ok(WasmInstr_F64_Gt),
      0x65S => Ok(WasmInstr_F64_Le),
      0x66S => Ok(WasmInstr_F64_Ge),
      0x67S => Ok(WasmInstr_I32_Clz),
      0x68S => Ok(WasmInstr_I32_Ctz),
      0x69S => Ok(WasmInstr_I32_Popcnt),
      0x6AS => Ok(WasmInstr_I32_Add),
      0x6BS => Ok(WasmInstr_I32_Sub),
      0x6CS => Ok(WasmInstr_I32_Mul),
      0x6DS => Ok(WasmInstr_I32_Div_S),
      0x6ES => Ok(WasmInstr_I32_Div_U),
      0x6FS => Ok(WasmInstr_I32_Rem_S),
      0x70S => Ok(WasmInstr_I32_Rem_U),
      0x71S => Ok(WasmInstr_I32_And),
      0x72S => Ok(WasmInstr_I32_Or),
      0x73S => Ok(WasmInstr_I32_Xor),
      0x74S => Ok(WasmInstr_I32_Shl),
      0x75S => Ok(WasmInstr_I32_Shr_S),
      0x76S => Ok(WasmInstr_I32_Shr_U),
      0x77S => Ok(WasmInstr_I32_Rotl),
      0x78S => Ok(WasmInstr_I32_Rotr),
      0x79S => Ok(WasmInstr_I64_Clz),
      0x7AS => Ok(WasmInstr_I64_Ctz),
      0x7BS => Ok(WasmInstr_I64_Popcnt),
      0x7CS => Ok(WasmInstr_I64_Add),
      0x7DS => Ok(WasmInstr_I64_Sub),
      0x7ES => Ok(WasmInstr_I64_Mul),
      0x7FS => Ok(WasmInstr_I64_Div_S),
      0x80S => Ok(WasmInstr_I64_Div_U),
      0x81S => Ok(WasmInstr_I64_Rem_S),
      0x82S => Ok(WasmInstr_I64_Rem_U),
      0x83S => Ok(WasmInstr_I64_And),
      0x84S => Ok(WasmInstr_I64_Or),
      0x85S => Ok(WasmInstr_I64_Xor),
      0x86S => Ok(WasmInstr_I64_Shl),
      0x87S => Ok(WasmInstr_I64_Shr_S),
      0x88S => Ok(WasmInstr_I64_Shr_U),
      0x89S => Ok(WasmInstr_I64_Rotl),
      0x8AS => Ok(WasmInstr_I64_Rotr),
      0x8BS => Ok(WasmInstr_F32_Abs),
      0x8CS => Ok(WasmInstr_F32_Neg),
      0x8DS => Ok(WasmInstr_F32_Ceil),
      0x8ES => Ok(WasmInstr_F32_Floor),
      0x8FS => Ok(WasmInstr_F32_Trunc),
      0x90S => Ok(WasmInstr_F32_Nearest),
      0x91S => Ok(WasmInstr_F32_Sqrt),
      0x92S => Ok(WasmInstr_F32_Add),
      0x93S => Ok(WasmInstr_F32_Sub),
      0x94S => Ok(WasmInstr_F32_Mul),
      0x95S => Ok(WasmInstr_F32_Div),
      0x96S => Ok(WasmInstr_F32_Min),
      0x97S => Ok(WasmInstr_F32_Max),
      0x98S => Ok(WasmInstr_F32_CopySign),
      0x99S => Ok(WasmInstr_F64_Abs),
      0x9AS => Ok(WasmInstr_F64_Neg),
      0x9BS => Ok(WasmInstr_F64_Ceil),
      0x9CS => Ok(WasmInstr_F64_Floor),
      0x9DS => Ok(WasmInstr_F64_Trunc),
      0x9ES => Ok(WasmInstr_F64_Nearest),
      0x9FS => Ok(WasmInstr_F64_Sqrt),
      0xA0S => Ok(WasmInstr_F64_Add),
      0xA1S => Ok(WasmInstr_F64_Sub),
      0xA2S => Ok(WasmInstr_F64_Mul),
      0xA3S => Ok(WasmInstr_F64_Div),
      0xA4S => Ok(WasmInstr_F64_Min),
      0xA5S => Ok(WasmInstr_F64_Max),
      0xA6S => Ok(WasmInstr_F64_CopySign),
      0xA7S => Ok(WasmInstr_I32_Wrap_I64),
      0xA8S => Ok(WasmInstr_I32_Trunc_F32_S),
      0xA9S => Ok(WasmInstr_I32_Trunc_F32_U),
      0xAAS => Ok(WasmInstr_I32_Trunc_F64_S),
      0xABS => Ok(WasmInstr_I32_Trunc_F64_U),
      0xACS => Ok(WasmInstr_I64_Extend_I32_S),
      0xADS => Ok(WasmInstr_I64_Extend_I32_U),
      0xAES => Ok(WasmInstr_I64_Trunc_F32_S),
      0xAFS => Ok(WasmInstr_I64_Trunc_F32_U),
      0xB0S => Ok(WasmInstr_I64_Trunc_F64_S),
      0xB1S => Ok(WasmInstr_I64_Trunc_F64_U),
      0xB2S => Ok(WasmInstr_F32_Convert_I32_S),
      0xB3S => Ok(WasmInstr_F32_Convert_I32_U),
      0xB4S => Ok(WasmInstr_F32_Convert_I64_S),
      0xB5S => Ok(WasmInstr_F32_Convert_I64_U),
      0xB6S => Ok(WasmInstr_F32_Demote_F64),
      0xB7S => Ok(WasmInstr_F64_Convert_I32_S),
      0xB8S => Ok(WasmInstr_F64_Convert_I32_U),
      0xB9S => Ok(WasmInstr_F64_Convert_I64_S),
      0xBAS => Ok(WasmInstr_F64_Convert_I64_U),
      0xBBS => Ok(WasmInstr_F64_Promote_F32),
      0xBCS => Ok(WasmInstr_I32_Reinterpret_F32),
      0xBDS => Ok(WasmInstr_I64_Reinterpret_F64),
      0xBES => Ok(WasmInstr_F32_Reinterpret_I32),
      0xBFS => Ok(WasmInstr_F64_Reinterpret_I64),
      0xC0S => Ok(WasmInstr_I32_Extend8_S),
      0xC1S => Ok(WasmInstr_I32_Extend16_S),
      0xC2S => Ok(WasmInstr_I64_Extend8_S),
      0xC3S => Ok(WasmInstr_I64_Extend16_S),
      0xC4S => Ok(WasmInstr_I64_Extend32_S),
      // TODO: Vector Instructions
      0xFDS => {
        let instrIndex = getUleb128AndAdvance(parserState, 32)
        match (instrIndex) {
          // Vector Load Store
          0 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load(memArg))
          },
          1 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_8x8_Load_S(memArg))
          },
          2 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_8x8_Load_U(memArg))
          },
          3 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_16x4_Load_S(memArg))
          },
          4 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_16x4_Load_U(memArg))
          },
          5 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_32x2_Load_S(memArg))
          },
          6 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_32x2_Load_S(memArg))
          },
          7 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_8_Splat(memArg))
          },
          8 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_16_Splat(memArg))
          },
          9 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_32_Splat(memArg))
          },
          10 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_64_Splat(memArg))
          },
          92 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_Load_32_Zero(memArg))
          },
          93 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_Load_64_Zero(memArg))
          },
          11 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Store(memArg))
          },
          84 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load8_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          85 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load16_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          86 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load32_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          87 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load64_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          88 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store8_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          89 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store16_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          90 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store32_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          91 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store64_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          12 => {
            let n = match (nextI128(parserState)) {
              Ok(n) => n,
              Err(e) => return Err(e),
            }
            Ok(WasmInstr_V128_Const(n))
          },
          13 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Shuffle(Int16.toNumber(laneIdx)))
          },
          21 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Extract_Lane_S(Int16.toNumber(laneIdx)))
          },
          22 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Extract_Lane_U(Int16.toNumber(laneIdx)))
          },
          23 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          24 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Extract_Lane_S(Int16.toNumber(laneIdx)))
          },
          25 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Extract_Lane_U(Int16.toNumber(laneIdx)))
          },
          26 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          27 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I32x4_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          28 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I32x4_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          29 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I64x2_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          30 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I64x2_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          31 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F32x4_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          32 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F32x4_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          33 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F64x2_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          34 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F64x2_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          14 => Ok(WasmInstr_I8x16_Swizzle),
          15 => Ok(WasmInstr_I8x16_Splat),
          16 => Ok(WasmInstr_I16x8_Splat),
          17 => Ok(WasmInstr_I32x4_Splat),
          18 => Ok(WasmInstr_I64x2_Splat),
          19 => Ok(WasmInstr_F32x4_Splat),
          20 => Ok(WasmInstr_F64x2_Splat),
          35 => Ok(WasmInstr_I8x16_Eq),
          36 => Ok(WasmInstr_I8x16_Ne),
          37 => Ok(WasmInstr_I8x16_Lt_S),
          38 => Ok(WasmInstr_I8x16_Lt_U),
          39 => Ok(WasmInstr_I8x16_Gt_S),
          40 => Ok(WasmInstr_I8x16_Gt_U),
          41 => Ok(WasmInstr_I8x16_Le_S),
          42 => Ok(WasmInstr_I8x16_Le_U),
          43 => Ok(WasmInstr_I8x16_Ge_S),
          44 => Ok(WasmInstr_I8x16_Ge_U),
          45 => Ok(WasmInstr_I16x8_Eq),
          46 => Ok(WasmInstr_I16x8_Ne),
          47 => Ok(WasmInstr_I16x8_Lt_S),
          48 => Ok(WasmInstr_I16x8_Lt_U),
          49 => Ok(WasmInstr_I16x8_Gt_S),
          50 => Ok(WasmInstr_I16x8_Gt_U),
          51 => Ok(WasmInstr_I16x8_Le_S),
          52 => Ok(WasmInstr_I16x8_Le_U),
          53 => Ok(WasmInstr_I16x8_Ge_S),
          54 => Ok(WasmInstr_I16x8_Ge_U),
          55 => Ok(WasmInstr_I32x4_Eq),
          56 => Ok(WasmInstr_I32x4_Ne),
          57 => Ok(WasmInstr_I32x4_Lt_S),
          58 => Ok(WasmInstr_I32x4_Lt_U),
          59 => Ok(WasmInstr_I32x4_Gt_S),
          60 => Ok(WasmInstr_I32x4_Gt_U),
          61 => Ok(WasmInstr_I32x4_Le_S),
          62 => Ok(WasmInstr_I32x4_Le_U),
          63 => Ok(WasmInstr_I32x4_Ge_S),
          64 => Ok(WasmInstr_I32x4_Ge_U),
          214 => Ok(WasmInstr_I64x2_Eq),
          215 => Ok(WasmInstr_I64x2_Ne),
          216 => Ok(WasmInstr_I64x2_Lt_S),
          217 => Ok(WasmInstr_I64x2_Gt_S),
          218 => Ok(WasmInstr_I64x2_Le_S),
          219 => Ok(WasmInstr_I64x2_Ge_S),
          65 => Ok(WasmInstr_F32x4_Eq),
          66 => Ok(WasmInstr_F32x4_Ne),
          67 => Ok(WasmInstr_F32x4_Lt),
          68 => Ok(WasmInstr_F32x4_Gt),
          69 => Ok(WasmInstr_F32x4_Le),
          70 => Ok(WasmInstr_F32x4_Ge),
          71 => Ok(WasmInstr_F64x2_Eq),
          72 => Ok(WasmInstr_F64x2_Ne),
          73 => Ok(WasmInstr_F64x2_Lt),
          74 => Ok(WasmInstr_F64x2_Gt),
          75 => Ok(WasmInstr_F64x2_Le),
          76 => Ok(WasmInstr_F64x2_Ge),
          77 => Ok(WasmInstr_V128_Not),
          78 => Ok(WasmInstr_V128_And),
          79 => Ok(WasmInstr_V128_And_Not),
          80 => Ok(WasmInstr_V128_Or),
          81 => Ok(WasmInstr_V128_Xor),
          82 => Ok(WasmInstr_V128_Bitselect),
          83 => Ok(WasmInstr_V128_Any_True),
          96 => Ok(WasmInstr_I8x16_Abs),
          97 => Ok(WasmInstr_I8x16_Neg),
          98 => Ok(WasmInstr_I8x16_Popcnt),
          99 => Ok(WasmInstr_I8x16_All_True),
          100 => Ok(WasmInstr_I8x16_Bitmask),
          101 => Ok(WasmInstr_I8x16_Narrow_I16x8_S),
          102 => Ok(WasmInstr_I8x16_Narrow_I16x8_U),
          107 => Ok(WasmInstr_I8x16_Shl),
          108 => Ok(WasmInstr_I8x16_Shr_S),
          109 => Ok(WasmInstr_I8x16_Shr_U),
          110 => Ok(WasmInstr_I8x16_Add),
          111 => Ok(WasmInstr_I8x16_Add_Sat_S),
          112 => Ok(WasmInstr_I8x16_Add_Sat_U),
          113 => Ok(WasmInstr_I8x16_Sub),
          114 => Ok(WasmInstr_I8x16_Sub_Sat_S),
          115 => Ok(WasmInstr_I8x16_Sub_Sat_U),
          118 => Ok(WasmInstr_I8x16_Min_S),
          119 => Ok(WasmInstr_I8x16_Min_U),
          120 => Ok(WasmInstr_I8x16_Max_S),
          121 => Ok(WasmInstr_I8x16_Max_U),
          123 => Ok(WasmInstr_I8x16_Avgr_U),
          124 => Ok(WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_S),
          125 => Ok(WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_U),
          128 => Ok(WasmInstr_I16x8_Abs),
          129 => Ok(WasmInstr_I16x8_Neg),
          130 => Ok(WasmInstr_I16x8_q15mulr_sat_s),
          131 => Ok(WasmInstr_I16x8_All_True),
          132 => Ok(WasmInstr_I16x8_Bitmask),
          133 => Ok(WasmInstr_I16x8_Narrow_I32x4_S),
          134 => Ok(WasmInstr_I16x8_Narrow_I32x4_U),
          135 => Ok(WasmInstr_I16x8_Extend_Low_I8x16_S),
          136 => Ok(WasmInstr_I16x8_Extend_High_I8x16_S),
          137 => Ok(WasmInstr_I16x8_Extend_Low_I8x16_U),
          138 => Ok(WasmInstr_I16x8_Extend_High_I8x16_U),
          139 => Ok(WasmInstr_I16x8_Shl),
          140 => Ok(WasmInstr_I16x8_Shr_S),
          141 => Ok(WasmInstr_I16x8_Shr_U),
          142 => Ok(WasmInstr_I16x8_Add),
          143 => Ok(WasmInstr_I16x8_Add_Sat_S),
          144 => Ok(WasmInstr_I16x8_Add_Sat_U),
          145 => Ok(WasmInstr_I16x8_Sub),
          146 => Ok(WasmInstr_I16x8_Sub_Sat_S),
          147 => Ok(WasmInstr_I16x8_Sub_Sat_U),
          149 => Ok(WasmInstr_I16x8_Mul),
          150 => Ok(WasmInstr_I16x8_Min_S),
          151 => Ok(WasmInstr_I16x8_Min_U),
          152 => Ok(WasmInstr_I16x8_Max_S),
          153 => Ok(WasmInstr_I16x8_Max_U),
          155 => Ok(WasmInstr_I16x8_Avgr_U),
          156 => Ok(WasmInstr_I16x8_ExtMulLow_I8x16_S),
          157 => Ok(WasmInstr_I16x8_ExtMulHigh_I8x16_S),
          158 => Ok(WasmInstr_I16x8_ExtMulLow_I8x16_U),
          159 => Ok(WasmInstr_I16x8_ExtMulHigh_I8x16_U),
          126 => Ok(WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_S),
          127 => Ok(WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_U),
          160 => Ok(WasmInstr_I32x4_Abs),
          161 => Ok(WasmInstr_I32x4_Neg),
          163 => Ok(WasmInstr_I32x4_All_True),
          164 => Ok(WasmInstr_I32x4_Bitmask),
          167 => Ok(WasmInstr_I32x4_Extend_Low_I16x8_S),
          168 => Ok(WasmInstr_I32x4_Extend_High_I16x8_S),
          169 => Ok(WasmInstr_I32x4_Extend_Low_I16x8_U),
          170 => Ok(WasmInstr_I32x4_Extend_High_I16x8_U),
          171 => Ok(WasmInstr_I32x4_Shl),
          172 => Ok(WasmInstr_I32x4_Shr_S),
          173 => Ok(WasmInstr_I32x4_Shr_U),
          174 => Ok(WasmInstr_I32x4_Add),
          177 => Ok(WasmInstr_I32x4_Sub),
          181 => Ok(WasmInstr_I32x4_Mul),
          182 => Ok(WasmInstr_I32x4_Min_S),
          183 => Ok(WasmInstr_I32x4_Min_U),
          184 => Ok(WasmInstr_I32x4_Max_S),
          185 => Ok(WasmInstr_I32x4_Max_U),
          186 => Ok(WasmInstr_I32x4_Dot_I16x8_S),
          188 => Ok(WasmInstr_I32x4_ExtMulLow_I16x8_S),
          189 => Ok(WasmInstr_I32x4_ExtMulHigh_I16x8_S),
          190 => Ok(WasmInstr_I32x4_ExtMulLow_I16x8_U),
          191 => Ok(WasmInstr_I32x4_ExtMulHigh_I16x8_U),
          192 => Ok(WasmInstr_I64x2_Abs),
          193 => Ok(WasmInstr_I64x2_Neg),
          195 => Ok(WasmInstr_I64x2_All_True),
          196 => Ok(WasmInstr_I64x2_Bitmask),
          199 => Ok(WasmInstr_I64x2_Extend_Low_I32x4_S),
          200 => Ok(WasmInstr_I64x2_Extend_High_I32x4_S),
          201 => Ok(WasmInstr_I64x2_Extend_Low_I32x4_U),
          202 => Ok(WasmInstr_I64x2_Extend_High_I32x4_U),
          203 => Ok(WasmInstr_I64x2_Shl),
          204 => Ok(WasmInstr_I64x2_Shr_S),
          205 => Ok(WasmInstr_I64x2_Shr_U),
          206 => Ok(WasmInstr_I64x2_Add),
          209 => Ok(WasmInstr_I64x2_Sub),
          213 => Ok(WasmInstr_I64x2_Mul),
          220 => Ok(WasmInstr_I64x2_ExtMulLow_I32x4_S),
          221 => Ok(WasmInstr_I64x2_ExtMulHigh_I32x4_S),
          222 => Ok(WasmInstr_I64x2_ExtMulLow_I32x4_U),
          223 => Ok(WasmInstr_I64x2_ExtMulHigh_I32x4_U),
          103 => Ok(WasmInstr_F32x4_Ceil),
          104 => Ok(WasmInstr_F32x4_Floor),
          105 => Ok(WasmInstr_F32x4_Trunc),
          106 => Ok(WasmInstr_F32x4_Nearest),
          224 => Ok(WasmInstr_F32x4_Abs),
          225 => Ok(WasmInstr_F32x4_Neg),
          227 => Ok(WasmInstr_F32x4_Sqrt),
          228 => Ok(WasmInstr_F32x4_Add),
          229 => Ok(WasmInstr_F32x4_Sub),
          230 => Ok(WasmInstr_F32x4_Mul),
          231 => Ok(WasmInstr_F32x4_Div),
          232 => Ok(WasmInstr_F32x4_Min),
          233 => Ok(WasmInstr_F32x4_Max),
          234 => Ok(WasmInstr_F32x4_Pmin),
          235 => Ok(WasmInstr_F32x4_Pmax),
          116 => Ok(WasmInstr_F64x2_Ceil),
          117 => Ok(WasmInstr_F64x2_Floor),
          122 => Ok(WasmInstr_F64x2_Trunc),
          148 => Ok(WasmInstr_F64x2_Nearest),
          236 => Ok(WasmInstr_F64x2_Abs),
          237 => Ok(WasmInstr_F64x2_Neg),
          239 => Ok(WasmInstr_F64x2_Sqrt),
          240 => Ok(WasmInstr_F64x2_Add),
          241 => Ok(WasmInstr_F64x2_Sub),
          242 => Ok(WasmInstr_F64x2_Mul),
          243 => Ok(WasmInstr_F64x2_Div),
          244 => Ok(WasmInstr_F64x2_Min),
          245 => Ok(WasmInstr_F64x2_Max),
          246 => Ok(WasmInstr_F64x2_Pmin),
          247 => Ok(WasmInstr_F64x2_Pmax),
          248 => Ok(WasmInstr_I32x4_Trunc_Sat_F32x4_S),
          249 => Ok(WasmInstr_I32x4_Trunc_Sat_F32x4_U),
          250 => Ok(WasmInstr_F32x4_Convert_I32x4_S),
          251 => Ok(WasmInstr_F32x4_Convert_I32x4_U),
          252 => Ok(WasmInstr_I32x4_Trunc_Sat_F64x2_S_Zero),
          253 => Ok(WasmInstr_I32x4_Trunc_Sat_F64x2_U_Zero),
          254 => Ok(WasmInstr_F64x2_ConvertLow_I32x4_S),
          255 => Ok(WasmInstr_F64x2_ConvertLow_I32x4_U),
          94 => Ok(WasmInstr_F32x4_Demote_F64x2_Zero),
          095 => Ok(WasmInstr_F64x2_PromoteLow_F32x4),
          // Invalid
          _ =>
            buildUnexpectedWasmTokenCustom(
              parserState,
              "0-255",
              toString(instrIndex)
            ),
        }
      },
      // 0xFC leading
      0xFCS => {
        let instrIndex = getUleb128AndAdvance(parserState, 32)
        match (instrIndex) {
          // Table Instructions
          12 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Init(elemIndex, tableIndex))
          },
          13 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Elem_Drop(elemIndex))
          },
          14 => {
            let tableIndex1 = getUleb128AndAdvance(parserState, 32)
            let tableIndex2 = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Copy(tableIndex1, tableIndex2))
          },
          15 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Grow(tableIndex))
          },
          16 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Size(tableIndex))
          },
          17 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Fill(tableIndex))
          },
          // Memory Instructions
          8 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Init(dataIndex))
          },
          9 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Data_Drop(dataIndex))
          },
          10 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Copy)
          },
          11 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Fill)
          },
          // Numeric Instructions
          0 => Ok(WasmInstr_I32_TruncSat_F32_S),
          1 => Ok(WasmInstr_I32_TruncSat_F32_U),
          2 => Ok(WasmInstr_I32_TruncSat_F64_S),
          3 => Ok(WasmInstr_I32_TruncSat_F64_U),
          4 => Ok(WasmInstr_I64_TruncSat_F32_S),
          5 => Ok(WasmInstr_I64_TruncSat_F32_U),
          6 => Ok(WasmInstr_I64_TruncSat_F64_S),
          7 => Ok(WasmInstr_I64_TruncSat_F64_U),
          // Invalid
          _ =>
            buildUnexpectedWasmTokenCustom(
              parserState,
              "0-17",
              toString(instrIndex)
            ),
        }
      },
      // End Instruction
      0x05S => Ok(WasmInstr_Else),
      0x0BS => Ok(WasmInstr_End),
      // Invalid
      c => Err(InvalidWasmInstr(c)),
    }
  },
  parseExpr = (parserState, parent) => {
    let mut exprs = []
    while (!isAtEndOfInput(parserState)) {
      let instr = parseInstr(parserState)
      match (instr) {
        Ok(instr) => {
          exprs = [instr, ...exprs]
          if (instr == WasmInstr_End) break
        },
        Err(err) => return Err(err),
      }
    }
    return Ok(List.reverse(exprs))
  }
  /**
   * Parse a section into a parsed wasm section.
   *
   * @param section: The unparsed section to parse
   *
   * @returns The parsed section
   */

  provide let parseSection = section => {
    // Match The Section
    let section = match (section) {
      RawCustomSection(bytes) => CustomSection(bytes),
      RawTypeSection(bytes) => {
        let parserState = makeParser(bytes)
        // This Contains Function Types
        let typeCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Function Types
        let mut functionTypes = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let functionType = parseFunctionType(parserState)
          match (functionType) {
            Ok(functionType) => {
              functionTypes = [functionType, ...functionTypes]
              void
            },
            Err(err) => return Err(err),
          }
        }
        TypeSection(List.reverse(functionTypes))
      },
      RawImportSection(bytes) => {
        let parserState = makeParser(bytes)
        let importCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Import Types
        let mut wasmImports = []
        for (let mut i = 0; i < importCount; i += 1) {
          let wasmImport = parseWasmImport(parserState)
          match (wasmImport) {
            Ok(wasmImport) => {
              wasmImports = [wasmImport, ...wasmImports]
              void
            },
            Err(err) => return Err(err),
          }
        }
        ImportSection(List.reverse(wasmImports))
      },
      RawFunctionSection(bytes) => {
        let parserState = makeParser(bytes)
        let funcCount = getUleb128AndAdvance(parserState, 32)
        let mut funcTypes = []
        for (let mut i = 0; i < funcCount; i += 1) {
          let funcType = getUleb128AndAdvance(parserState, 32)
          funcTypes = [funcType, ...funcTypes]
        }
        FunctionSection(List.reverse(funcTypes))
      },
      RawTableSection(bytes) => {
        let parserState = makeParser(bytes)
        let tableCount = getUleb128AndAdvance(parserState, 32)
        let mut tableTypes = []
        for (let mut i = 0; i < tableCount; i += 1) {
          let tableType = match (parseTableType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          tableTypes = [tableType, ...tableTypes]
        }
        TableSection(List.reverse(tableTypes))
      },
      RawMemorySection(bytes) => {
        let parserState = makeParser(bytes)
        let memCount = getUleb128AndAdvance(parserState, 32)
        let mut memTypes = []
        for (let mut i = 0; i < memCount; i += 1) {
          let (minLimit, maxLimit) = match (parseLimits(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          memTypes = [(minLimit, maxLimit), ...memTypes]
        }
        MemorySection(List.reverse(memTypes))
      },
      RawGlobalSection(bytes) => {
        let parserState = makeParser(bytes)
        let globalCount = getUleb128AndAdvance(parserState, 32)
        let mut globalTypes = []
        for (let mut i = 0; i < globalCount; i += 1) {
          let globalType = match (parseGlobalType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          let globalValue = match (parseExpr(parserState, ParentGlobal)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          globalTypes = [(globalType, globalValue), ...globalTypes]
        }
        GlobalSection(List.reverse(globalTypes))
      },
      RawExportSection(bytes) => {
        let parserState = makeParser(bytes)
        let exportCount = getUleb128AndAdvance(parserState, 32)
        let mut exports = []
        for (let mut i = 0; i < exportCount; i += 1) {
          // Parse Export Name
          let name = getStringAndAdvance(parserState)
          nextByteU(parserState)
          // Parse Export Description
          let exportDescType = parserState.currentByte
          nextByteU(parserState)
          let idx = getUleb128AndAdvance(parserState, 32)
          let exportDesc = match (exportDescType) {
            0x00S => FuncExport(idx),
            0x01S => TableExport(idx),
            0x02S => MemoryExport(idx),
            0x03S => GlobalExport(idx),
            c => return Err(InvalidExportDescription(c)),
          }
          exports = [{ name, exportDesc }: WasmExportType, ...exports]
        }
        ExportSection(List.reverse(exports))
      },
      RawStartSection(bytes) => {
        let parserState = makeParser(bytes)
        let startIdx = getUleb128AndAdvance(parserState, 32)
        StartSection(startIdx)
      },
      RawElementSection(bytes) => {
        let parserState = makeParser(bytes)
        let elementCount = getUleb128AndAdvance(parserState, 32)
        let mut elements = []
        for (let mut i = 0; i < elementCount; i += 1) {
          let elementType = getUleb128AndAdvance(parserState, 32)
          match (elementType) {
            0 => {
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: WasmFuncRef,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemActive{ tableIdx: 0, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            1 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemPassive,
                }: WasmElementSegment,
                ...elements
              ]
            },
            2 => {
              let tableIndex = getUleb128AndAdvance(parserState, 32)
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemActive{ tableIdx: tableIndex, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            3 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemDeclarative,
                }: WasmElementSegment,
                ...elements
              ]
            },
            4 => {
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: WasmFuncRef,
                  contents: List.reverse(exprs),
                  elemMode: ElemActive{ tableIdx: 0, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            5 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemPassive,
                }: WasmElementSegment,
                ...elements
              ]
            },
            6 => {
              let tableIndex = getUleb128AndAdvance(parserState, 32)
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemActive{ tableIdx: tableIndex, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            7 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemDeclarative,
                }: WasmElementSegment,
                ...elements
              ]
            },
            _ =>
              return buildUnexpectedWasmTokenCustom(
                parserState,
                "0-7",
                toString(elementType)
              ),
          }
        }
        ElementSection(List.reverse(elements))
      },
      RawDataCountSection(bytes) => {
        let parserState = makeParser(bytes)
        let dataCount = getUleb128AndAdvance(parserState, 32)
        DataCountSection(dataCount)
      },
      RawCodeSection(bytes) => {
        let parserState = makeParser(bytes)
        let codeCount = getUleb128AndAdvance(parserState, 32)
        let mut functions = []
        for (let mut i = 0; i < codeCount; i += 1) {
          // Get Function Size
          let funcSize = getUleb128AndAdvance(parserState, 32)
          // Get Function Locals
          let localCount = getUleb128AndAdvance(parserState, 32)
          let mut locals = []
          for (let mut j = 0; j < localCount; j += 1) {
            let localTypeCount = getUleb128AndAdvance(parserState, 32)
            let localType = match (parseWasmType(parserState)) {
              Ok(t) => t,
              Err(e) => return Err(e),
            }
            locals = [
              { wasmType: localType, count: localTypeCount }: WasmLocalType,
              ...locals
            ]
          }
          // Parse The Function Body
          let wasmBody = match (parseExpr(parserState, ParentFunction)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          // Add To List
          functions = [
            { locals: List.reverse(locals), body: wasmBody }: WasmFunctionType,
            ...functions
          ]
        }
        CodeSection(List.reverse(functions))
      },
      RawDataSection(bytes) => {
        let parserState = makeParser(bytes)
        let dataCount = getUleb128AndAdvance(parserState, 32)
        let mut data = []
        for (let mut i = 0; i < dataCount; i += 1) {
          // Parse Each Section
          let dataLayout = getUleb128AndAdvance(parserState, 32)
          match (dataLayout) {
            0 => {
              let expr = match (parseExpr(parserState, ParentData)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataActive{ memIdx: 0, offset: expr, content }, ...data]
            },
            1 => {
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataPassive{ content, }, ...data]
            },
            2 => {
              // Get Memory Index
              let memIdx = getUleb128AndAdvance(parserState, 32)
              // Get Offset
              let expr = match (parseExpr(parserState, ParentData)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataActive{ memIdx, offset: expr, content }, ...data]
            },
            _ =>
              return buildUnexpectedWasmTokenCustom(
                parserState,
                "0-2",
                toString(dataLayout)
              ),
          }
        }
        DataSection(List.reverse(data))
      },
    }
    // Return
    return Ok(section)
  }
}
// TODO: Builder
