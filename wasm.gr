module Wasm

include "Bytes"
include "Int16"
include "list"
include "string"
include "runtime/numberUtils"
include "runtime/numbers"
include "runtime/dataStructures"
include "runtime/debugPrint"
include "runtime/unsafe/wasmi32"
include "runtime/unsafe/wasmf32"
include "runtime/unsafe/wasmf64"
from Numbers use { coerceNumberToWasmI32 }
from DataStructures use { tagInt16, newFloat32, newFloat64 }
// Types
provide enum WasmParseError {
  UnexpectedWasmToken(String),
  InvalidWasmType(Int16),
  InvalidImportDescType(Int16),
  InvalidWasmLimitType(Int16),
  InvalidWasmGlobal,
  InvalidExportDescription(Int16),
  InvalidWasmInstr(Int16),
  UnexpectedEndOfInput,
}
enum Parent {
  ParentFunction,
  ParentGlobal,
  ParentBlock,
}
provide enum RawSections {
  RawCustomSection(Bytes),
  RawTypeSection(Bytes),
  RawImportSection(Bytes),
  RawFunctionSection(Bytes),
  RawTableSection(Bytes),
  RawMemorySection(Bytes),
  RawGlobalSection(Bytes),
  RawExportSection(Bytes),
  RawStartSection(Bytes),
  RawElementSection(Bytes),
  RawDataCountSection(Bytes),
  RawCodeSection(Bytes),
  RawDataSection(Bytes),
}
provide enum WasmExportDesc {
  FuncExport(Number),
  TableExport(Number),
  MemoryExport(Number),
  GlobalExport(Number),
}
enum WasmTypeDesc {
  AllType,
  FuncType,
  NumType,
  VecType,
  RefType,
}
provide enum WasmType {
  // FuncType
  WasmFuncType(List<WasmType>, List<WasmType>),
  // NumberType
  WasmI32,
  WasmI64,
  WasmF32,
  WasmF64,
  // VectorType
  WasmV128,
  // RefType
  WasmFuncRef,
  WasmExternRef,
  // Special
  EmptyType,
  TypeIdx(Number),
}
provide enum WasmInstr {
  // Control Instructions
  WasmInstrUnreachable,
  WasmInstrNop,
  WasmInstrBlock(WasmType, List<WasmInstr>),
  WasmInstrLoop(WasmType, List<WasmInstr>),
  WasmInstrIf(WasmType, List<WasmInstr>),
  WasmInstrIfElse(WasmType, List<WasmInstr>, List<WasmInstr>),
  WasmInstrBr(Number),
  WasmInstrBrIf(Number),
  WasmInstrBrTable(List<Number>, Number),
  WasmInstrReturn,
  WasmInstrCall(Number),
  // TODO: Consider making this WasmType
  WasmInstrCallIndirect(Number, Number),
  WasmInstrReturnCall(Number),
  // TODO: Consider making this WasmType
  WasmInstrReturnCallIndirect(Number, Number),
  // Reference Instructions
  WasmInstrRefNull(WasmType),
  WasmInstrRefIsNUll,
  WasmInstrRefFunc(Number),
  // Parametric Instructions
  WasmInstrDrop,
  WasmInstrSelect(Option<List<WasmType>>),
  // Variable Instructions
  WasmInstrLocalGet(Number),
  WasmInstrLocalSet(Number),
  WasmInstrLocalTee(Number),
  WasmInstrGlobalGet(Number),
  WasmInstrGlobalSet(Number),
  // Table Instructions
  WasmInstrTableGet(Number),
  WasmInstrTableSet(Number),
  WasmInstrTableInit(Number, Number),
  WasmInstrElemDrop(Number),
  WasmInstrTableCopy(Number, Number),
  WasmInstrTableGrow(Number),
  WasmInstrTableSize(Number),
  WasmInstrTableFill(Number),
  // Memory Instructions
  WasmInstrI32Load{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load{
    align: Number,
    offset: Number,
  },
  WasmInstrF32Load{
    align: Number,
    offset: Number,
  },
  WasmInstrF64Load{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Load8S{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Load8U{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Load16S{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Load16U{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load8S{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load8U{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load16S{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load16U{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load32S{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Load32U{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Store{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Store{
    align: Number,
    offset: Number,
  },
  WasmInstrF32Store{
    align: Number,
    offset: Number,
  },
  WasmInstrF64Store{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Store8{
    align: Number,
    offset: Number,
  },
  WasmInstrI32Store16{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Store8{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Store16{
    align: Number,
    offset: Number,
  },
  WasmInstrI64Store32{
    align: Number,
    offset: Number,
  },
  WasmInstrMemorySize,
  WasmInstrMemoryGrow,
  WasmInstrMemoryInit(Number),
  WasmInstrDataDrop(Number),
  WasmInstrMemoryCopy,
  WasmInstrMemoryFill,
  // Numeric Instructions
  WasmInstrI32Const(Number),
  WasmInstrI64Const(Number),
  WasmInstrF32Const(Number),
  WasmInstrF64Const(Number),
  WasmInstrI32Eqz,
  WasmInstrI32Eq,
  WasmInstrI32Ne,
  WasmInstrI32LtS,
  WasmInstrI32LtU,
  WasmInstrI32GtS,
  WasmInstrI32GtU,
  WasmInstrI32LeS,
  WasmInstrI32LeU,
  WasmInstrI32GeS,
  WasmInstrI32GeU,
  WasmInstrI64Eqz,
  WasmInstrI64Eq,
  WasmInstrI64Ne,
  WasmInstrI64LtS,
  WasmInstrI64LtU,
  WasmInstrI64GtS,
  WasmInstrI64GtU,
  WasmInstrI64LeS,
  WasmInstrI64LeU,
  WasmInstrI64GeS,
  WasmInstrI64GeU,
  WasmInstrF32Eq,
  WasmInstrF32Ne,
  WasmInstrF32Lt,
  WasmInstrF32Gt,
  WasmInstrF32Le,
  WasmInstrF32Ge,
  WasmInstrF64Eq,
  WasmInstrF64Ne,
  WasmInstrF64Lt,
  WasmInstrF64Gt,
  WasmInstrF64Le,
  WasmInstrF64Ge,
  WasmInstrI32Clz,
  WasmInstrI32Ctz,
  WasmInstrI32Popcnt,
  WasmInstrI32Add,
  WasmInstrI32Sub,
  WasmInstrI32Mul,
  WasmInstrI32DivS,
  WasmInstrI32DivU,
  WasmInstrI32RemS,
  WasmInstrI32RemU,
  WasmInstrI32And,
  WasmInstrI32Or,
  WasmInstrI32Xor,
  WasmInstrI32Shl,
  WasmInstrI32ShrS,
  WasmInstrI32ShrU,
  WasmInstrI32Rotl,
  WasmInstrI32Rotr,
  WasmInstrI64Clz,
  WasmInstrI64Ctz,
  WasmInstrI64Popcnt,
  WasmInstrI64Add,
  WasmInstrI64Sub,
  WasmInstrI64Mul,
  WasmInstrI64DivS,
  WasmInstrI64DivU,
  WasmInstrI64RemS,
  WasmInstrI64RemU,
  WasmInstrI64And,
  WasmInstrI64Or,
  WasmInstrI64Xor,
  WasmInstrI64Shl,
  WasmInstrI64ShrS,
  WasmInstrI64ShrU,
  WasmInstrI64Rotl,
  WasmInstrI64Rotr,
  WasmInstrF32Abs,
  WasmInstrF32Neg,
  WasmInstrF32Ceil,
  WasmInstrF32Floor,
  WasmInstrF32Trunc,
  WasmInstrF32Nearest,
  WasmInstrF32Sqrt,
  WasmInstrF32Add,
  WasmInstrF32Sub,
  WasmInstrF32Mul,
  WasmInstrF32Div,
  WasmInstrF32Min,
  WasmInstrF32Max,
  WasmInstrF32CopySign,
  WasmInstrF64Abs,
  WasmInstrF64Neg,
  WasmInstrF64Ceil,
  WasmInstrF64Floor,
  WasmInstrF64Trunc,
  WasmInstrF64Nearest,
  WasmInstrF64Sqrt,
  WasmInstrF64Add,
  WasmInstrF64Sub,
  WasmInstrF64Mul,
  WasmInstrF64Div,
  WasmInstrF64Min,
  WasmInstrF64Max,
  WasmInstrF64CopySign,
  WasmInstrI32WrapI64,
  WasmInstrI32TruncF32S,
  WasmInstrI32TruncF32U,
  WasmInstrI32TruncF64S,
  WasmInstrI32TruncF64U,
  WasmInstrI64ExtendI32S,
  WasmInstrI64ExtendI32U,
  WasmInstrI64TruncF32S,
  WasmInstrI64TruncF32U,
  WasmInstrI64TruncF64S,
  WasmInstrI64TruncF64U,
  WasmInstrF32ConvertI32S,
  WasmInstrF32ConvertI32U,
  WasmInstrF32ConvertI64S,
  WasmInstrF32ConvertI64U,
  WasmInstrF32DemoteF64,
  WasmInstrF64ConvertI32S,
  WasmInstrF64ConvertI32U,
  WasmInstrF64ConvertI64S,
  WasmInstrF64ConvertI64U,
  WasmInstrF64PromoteF32,
  WasmInstrI32ReinterpretF32,
  WasmInstrI64ReinterpretF64,
  WasmInstrF32ReinterpretI32,
  WasmInstrF64ReinterpretI64,
  WasmInstrI32Extend8S,
  WasmInstrI32Extend16S,
  WasmInstrI64Extend8S,
  WasmInstrI64Extend16S,
  WasmInstrI64Extend32S,
  WasmInstrI32TruncSatF32S,
  WasmInstrI32TruncSatF32U,
  WasmInstrI32TruncSatF64S,
  WasmInstrI32TruncSatF64U,
  WasmInstrI64TruncSatF32S,
  WasmInstrI64TruncSatF32U,
  WasmInstrI64TruncSatF64S,
  WasmInstrI64TruncSatF64U,
  // TODO: Vector Instructions
  // End
  WasmInstrElse,
  WasmInstrEnd,
}
provide record WasmTableType {
  wasmType: WasmType,
  minLimit: Number,
  maxLimit: Option<Number>,
}
provide record WasmGlobalType {
  wasmType: WasmType,
  isMutable: Bool,
}
provide record WasmExportType {
  name: String,
  exportDesc: WasmExportDesc,
}
provide record WasmLocalType {
  wasmType: WasmType,
  count: Number,
}
provide record WasmFunctionType {
  locals: List<WasmLocalType>,
  body: List<WasmInstr>,
}
provide enum WasmImportDesc {
  WasmFuncImportDesc(Number),
  WasmTableImportDesc(WasmTableType),
  WasmMemoryImportDesc(Number, Option<Number>),
  WasmGlobalImportDesc(WasmGlobalType),
}
provide record WasmImport {
  importModName: String,
  importName: String,
  importDesc: WasmImportDesc,
}
provide enum Sections {
  CustomSection(Bytes),
  TypeSection(List<WasmType>),
  ImportSection(List<WasmImport>),
  FunctionSection(List<Number>),
  TableSection(List<WasmTableType>),
  MemorySection(List<(Number, Option<Number>)>),
  GlobalSection(List<(WasmGlobalType, List<WasmInstr>)>),
  ExportSection(List<WasmExportType>),
  StartSection(Number),
  ElementSection(Void),
  DataCountSection(Number),
  CodeSection(List<WasmFunctionType>),
  DataSection(Void),
}
// Helpers
record WasmParserState {
  bytes: Bytes,
  mut currentByte: Int16,
  mut pos: Number,
}
let _END_OF_INPUT = -1S
// Errors
@unsafe
let toHex = (n: Number) => {
  let x = coerceNumberToWasmI32(n)
  NumberUtils.itoa32(x, 16n)
}
let toHexWithZeroPadding = (n: Number, padTo: Number) => {
  // Note that this function is only called in exceptional cases so no effort
  // was made to optimize it.
  let mut result = toHex(n)
  while (String.length(result) < padTo) {
    result = "0" ++ result
  }
  result
}
let formatByteOrEOL = byte => {
  if (byte == _END_OF_INPUT) "End Of Input"
  else "0x" ++
    toHex(Int16.toNumber(byte))
}
let buildUnexpectedWasmToken =
  (
    parserState: WasmParserState,
    expected: Int16,
    found: Int16,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      formatByteOrEOL(expected) ++
      ", found: " ++
      formatByteOrEOL(found)
    )
  )
}
let buildUnexpectedWasmTokenCustom =
  (
    parserState: WasmParserState,
    expected: String,
    found: String,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      expected ++
      ", found: " ++
      found
    )
  )
}
// Streaming
@unsafe
let _INT8_BYTE_SIZE = 1n
@unsafe
let _FLOAT32_BYTE_SIZE = 4n
@unsafe
let _FLOAT64_BYTE_SIZE = 8n
@unsafe
let _SIZE_OFFSET = 4n
@unsafe
let _VALUE_OFFSET = 8n
let isAtEndOfInput = parserState => {
  parserState.currentByte == _END_OF_INPUT
}
@unsafe
let readByte = (idx: Number, bytes: Bytes) => {
  from WasmI32 use { add as (+), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(idx)
  if (offset + _INT8_BYTE_SIZE > size) {
    _END_OF_INPUT
  } else {
    let n = WasmI32.load8U(ptr + offset, _VALUE_OFFSET)
    tagInt16(n)
  }
}
let nextByteU = parserState => {
  let mut c = parserState.currentByte
  if (c != _END_OF_INPUT) {
    c = readByte(parserState.pos, parserState.bytes)
    parserState.currentByte = c
    parserState.pos += 1
  }
  c
}
@unsafe
let nextF32 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 4
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { add as (+), sub as (-), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 4n
  if (offset + _FLOAT32_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let n = WasmF32.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat32(n)): Number)
  }
}
@unsafe
let nextF64 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 8
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { add as (+), sub as (-), gtS as (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 8n
  if (offset + _FLOAT64_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let n = WasmF64.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat64(n)): Number)
  }
}
let getUleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    result = result | (byte & 0x7f) << shift
    nextByteU(parserState)
    if ((0x80 & byte) == 0) break
    shift += 7
  }
  // Return Result
  result
}
let getleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    nextByteU(parserState)
    result = result | (byte & 0x7f) << shift
    shift += 7
    if ((0x80 & byte) == 0) {
      if (shift < 32 && (byte & 0x40) != 0) {
        result = result | -1 << shift
      }
      break
    }
  }
  // Return Result
  result
}
let getStringAndAdvance = parserState => {
  // TODO: Optimize this using unsafe
  // Get String Length
  let stringLen = getUleb128AndAdvance(parserState, 32)
  // Get The String
  let str = Bytes.slice(parserState.pos - 1, stringLen, parserState.bytes)
  let str = Bytes.toString(str)
  parserState.pos += stringLen - 1
  // Return The String
  str
}
let expectByteAndAdvance =
  (
    expectedByte: Int16,
    parserState: WasmParserState,
  ) => {
  let c = parserState.currentByte
  if (c == expectedByte) {
    nextByteU(parserState)
    None
  } else {
    Some(buildUnexpectedWasmToken(parserState, expectedByte, c))
  }
}
let makeParser = bytes => {
  let parserState = {
    bytes,
    currentByte: readByte(0, bytes),
    pos: 1,
  }: WasmParserState
  parserState
}
let saveParser = parserState => (parserState.pos, parserState.currentByte)
let loadParser = (parserState, (pos, currentByte)) => {
  parserState.pos = pos
  parserState.currentByte = currentByte
}
// Parser
provide module Parser {
  // Parse File
  provide let parseModule = rawBytes => {
    // Build Our Parser State
    let parserState = makeParser(rawBytes)
    // Check For Magic Number
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x61S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x73S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x6dS, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Check For Version
    match (expectByteAndAdvance(0x01S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse Sections
    let mut wasmFile = []
    while (!isAtEndOfInput(parserState)) {
      from Int16 use { (<), (>) }
      let sectionID = parserState.currentByte
      nextByteU(parserState)
      // Validate SectionID
      let sectionLen = getUleb128AndAdvance(parserState, 32)
      // Collect Data
      let sectionContent = Bytes.slice(
        parserState.pos - 1,
        sectionLen,
        parserState.bytes
      )
      parserState.pos += sectionLen - 1
      nextByteU(parserState)
      // Collect The Bytes Object We Need
      wasmFile = match (sectionID) {
        0S => [RawCustomSection(sectionContent), ...wasmFile],
        1S => [RawTypeSection(sectionContent), ...wasmFile],
        2S => [RawImportSection(sectionContent), ...wasmFile],
        3S => [RawFunctionSection(sectionContent), ...wasmFile],
        4S => [RawTableSection(sectionContent), ...wasmFile],
        5S => [RawMemorySection(sectionContent), ...wasmFile],
        6S => [RawGlobalSection(sectionContent), ...wasmFile],
        7S => [RawExportSection(sectionContent), ...wasmFile],
        8S => [RawStartSection(sectionContent), ...wasmFile],
        9S => [RawElementSection(sectionContent), ...wasmFile],
        10S => [RawCodeSection(sectionContent), ...wasmFile],
        11S => [RawDataSection(sectionContent), ...wasmFile],
        12S => [RawDataCountSection(sectionContent), ...wasmFile],
        _ => {
          return buildUnexpectedWasmTokenCustom(
            parserState,
            "0-12",
            toString(sectionID)
          )
        },
      }
    }
    // Return
    return Ok(List.reverse(wasmFile))
  }
  // Parse Section
  let parseLimits = parserState => {
    let limitType = parserState.currentByte
    nextByteU(parserState)
    let minLimit = getUleb128AndAdvance(parserState, 32)
    let maxLimit = match (limitType) {
      0x00S => None,
      0x01S => Some(getUleb128AndAdvance(parserState, 32)),
      _ => return Err(InvalidWasmLimitType(limitType)),
    }
    return Ok((minLimit, maxLimit))
  }
  let parseWasmType = (parserState, typeFilter=AllType) => {
    let wasmType = match (parserState.currentByte) {
      // NumType
      0x7fS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI32),
      0x7eS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI64),
      0x7dS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF32),
      0x7cS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF64),
      // VecType
      0x7BS when typeFilter == AllType || typeFilter == VecType => Ok(WasmV128),
      // RefType
      0x70S when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmFuncRef),
      0x6fS when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmExternRef),
      // Unknown Type
      c => Err(InvalidWasmType(c)),
    }
    nextByteU(parserState)
    wasmType
  }
  let parseFunctionType = parserState => {
    // Expect The Function Start Type
    match (expectByteAndAdvance(0x60S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse The Params
    let paramCount = getUleb128AndAdvance(parserState, 32)
    let mut params = []
    for (let mut i = 0; i < paramCount; i += 1) {
      let paramType = parseWasmType(parserState, typeFilter=NumType)
      match (paramType) {
        Ok(paramType) => {
          params = [paramType, ...params]
        },
        Err(err) => return Err(err),
      }
    }
    // Parse The Result
    let resultCount = getUleb128AndAdvance(parserState, 32)
    let mut results = []
    for (let mut i = 0; i < resultCount; i += 1) {
      let resultType = parseWasmType(parserState, typeFilter=NumType)
      match (resultType) {
        Ok(resultType) => {
          results = [resultType, ...results]
        },
        Err(err) => return Err(err),
      }
    }
    // Return
    return Ok(WasmFuncType(List.reverse(params), List.reverse(results)))
  }
  let parseTableType = parserState => {
    let tableType = match (parseWasmType(parserState, typeFilter=RefType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let (minLimit, maxLimit) = match (parseLimits(parserState)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    return Ok({ wasmType: tableType, minLimit, maxLimit }: WasmTableType)
  }
  let parseGlobalType = parserState => {
    let valType = match (parseWasmType(parserState, typeFilter=NumType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let mutable = match (parserState.currentByte) {
      0x00S => false,
      0x01S => true,
      _ => return Err(InvalidWasmGlobal),
    }
    return Ok({ wasmType: valType, isMutable: mutable }: WasmGlobalType)
  }
  let parseWasmImport = parserState => {
    let importModName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importDescType = parserState.currentByte
    nextByteU(parserState)
    // Parse The Import Description
    let importDesc = match (importDescType) {
      0x00S => {
        let typeID = getUleb128AndAdvance(parserState, 32)
        nextByteU(parserState)
        WasmFuncImportDesc(typeID)
      },
      0x01S => {
        let tableType = match (parseTableType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmTableImportDesc(tableType)
      },
      0x02S => {
        let (minLimit, maxLimit) = match (parseLimits(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmMemoryImportDesc(minLimit, maxLimit)
      },
      0x03S => {
        let globalType = match (parseGlobalType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmGlobalImportDesc(globalType)
      },
      _ => return Err(InvalidImportDescType(importDescType)),
    }
    // Return The Import
    return Ok({ importModName, importName, importDesc }: WasmImport)
  }
  let parseBlockType = parserState => {
    match (parserState.currentByte) {
      0x40S => {
        nextByteU(parserState)
        return Ok(EmptyType)
      },
      _ => {
        let savePoint = saveParser(parserState)
        let wasmType = match (parseWasmType(parserState, typeFilter=NumType)) {
          Ok(t) => Ok(t),
          Err(e) => {
            loadParser(parserState, savePoint)
            let typeIdx = getleb128AndAdvance(parserState, 33)
            // TODO: I think this requires special logic because its signed and 33 bit so it wont map properly to our type IDX
            Ok(TypeIdx(typeIdx))
          },
        }
        return wasmType
      },
    }
  }
  let parseMemArg = parserState => {
    let align = getUleb128AndAdvance(parserState, 32)
    let offset = getUleb128AndAdvance(parserState, 32)
    return (align, offset)
  }
  let rec parseInstr = parserState => {
    let c = parserState.currentByte
    nextByteU(parserState)
    return match (c) {
      // Control Expression
      0x00S => Ok(WasmInstrUnreachable),
      0x01S => Ok(WasmInstrNop),
      0x02S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstrBlock(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x03S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstrLoop(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x04S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        // Parse If
        let mut ifSection = []
        let mut hasElse = false
        while (!isAtEndOfInput(parserState)) {
          let instr = parseInstr(parserState)
          match (instr) {
            Ok(instr) => {
              ifSection = [instr, ...ifSection]
              if (instr == WasmInstrElse) hasElse = true
              if (instr == WasmInstrElse || instr == WasmInstrEnd) break
            },
            Err(err) => return Err(err),
          }
        }
        match (hasElse) {
          true => {
            let elseSection = parseExpr(parserState, ParentBlock)
            match (elseSection) {
              Ok(elseSection) =>
                Ok(WasmInstrIfElse(blockType, ifSection, elseSection)),
              Err(err) => return Err(err),
            }
          },
          false => Ok(WasmInstrIf(blockType, ifSection)),
        }
      },
      0x0CS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrBr(labelIdx))
      },
      0x0DS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrBrIf(labelIdx))
      },
      0x0ES => {
        let labelCount = getUleb128AndAdvance(parserState, 32)
        let mut labelIdxs = []
        for (let mut i = 0; i < labelCount; i += 1) {
          let labelIdx = getUleb128AndAdvance(parserState, 32)
          labelIdxs = [labelIdx, ...labelIdxs]
        }
        let defaultLabel = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrBrTable(List.reverse(labelIdxs), defaultLabel))
      },
      0x0FS => Ok(WasmInstrReturn),
      0x10S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrCall(funcIdx))
      },
      0x11S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrCallIndirect(typeIdx, tableIdx))
      },
      0x12S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrReturnCall(funcIdx))
      },
      0x13S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrReturnCallIndirect(typeIdx, tableIdx))
      },
      // Reference Instructions
      0xD0S => {
        let refType = match (parseWasmType(parserState, typeFilter=RefType)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        Ok(WasmInstrRefNull(refType))
      },
      0xD1S => Ok(WasmInstrRefIsNUll),
      0xD2S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrRefFunc(funcIdx))
      },
      // Parametric Instructions
      0x1AS => Ok(WasmInstrDrop),
      0x1BS => Ok(WasmInstrSelect(None)),
      0x1CS => {
        let typeCount = getUleb128AndAdvance(parserState, 32)
        let mut types = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let wasmType = match (parseWasmType(
            parserState,
            typeFilter=NumType
          )) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          types = [wasmType, ...types]
        }
        Ok(WasmInstrSelect(Some(List.reverse(types))))
      },
      // Variable Instructions
      0x20S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrLocalGet(localIdx))
      },
      0x21S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrLocalSet(localIdx))
      },
      0x22S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrLocalTee(localIdx))
      },
      0x23S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrGlobalGet(globalIdx))
      },
      0x24S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrGlobalSet(globalIdx))
      },
      // Table Instructions
      0x25S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrTableGet(tableIdx))
      },
      0x26S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstrTableSet(tableIdx))
      },
      // Memory Instructions
      0x28S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Load{ align, offset })
      },
      0x29S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load{ align, offset })
      },
      0x2AS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrF32Load{ align, offset })
      },
      0x2BS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrF64Load{ align, offset })
      },
      0x2CS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Load8S{ align, offset })
      },
      0x2DS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Load8U{ align, offset })
      },
      0x2ES => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Load16S{ align, offset })
      },
      0x2FS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Load16U{ align, offset })
      },
      0x30S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load8S{ align, offset })
      },
      0x31S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load8U{ align, offset })
      },
      0x32S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load16S{ align, offset })
      },
      0x33S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load16U{ align, offset })
      },
      0x34S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load32S{ align, offset })
      },
      0x35S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Load32U{ align, offset })
      },
      0x36S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Store{ align, offset })
      },
      0x37S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Store{ align, offset })
      },
      0x38S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrF32Store{ align, offset })
      },
      0x39S => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrF64Store{ align, offset })
      },
      0x3AS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Store8{ align, offset })
      },
      0x3BS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI32Store16{ align, offset })
      },
      0x3CS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Store8{ align, offset })
      },
      0x3DS => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Store16{ align, offset })
      },
      0x3ES => {
        let (align, offset) = parseMemArg(parserState)
        Ok(WasmInstrI64Store32{ align, offset })
      },
      0x3FS => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstrMemorySize)
      },
      0x40S => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstrMemoryGrow)
      },
      // Numeric Instructions
      0x41S => {
        let value = getleb128AndAdvance(parserState, 32)
        Ok(WasmInstrI32Const(value))
      },
      0x42S => {
        let value = getleb128AndAdvance(parserState, 64)
        Ok(WasmInstrI64Const(value))
      },
      0x43S => {
        let value = match (nextF32(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstrF32Const(value))
      },
      0x44S => {
        let value = match (nextF64(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstrF64Const(value))
      },
      0x45S => Ok(WasmInstrI32Eqz),
      0x46S => Ok(WasmInstrI32Eq),
      0x47S => Ok(WasmInstrI32Ne),
      0x48S => Ok(WasmInstrI32LtS),
      0x49S => Ok(WasmInstrI32LtU),
      0x4AS => Ok(WasmInstrI32GtS),
      0x4BS => Ok(WasmInstrI32GtU),
      0x4CS => Ok(WasmInstrI32LeS),
      0x4DS => Ok(WasmInstrI32LeU),
      0x4ES => Ok(WasmInstrI32GeS),
      0x4FS => Ok(WasmInstrI32GeU),
      0x50S => Ok(WasmInstrI64Eqz),
      0x51S => Ok(WasmInstrI64Eq),
      0x52S => Ok(WasmInstrI64Ne),
      0x53S => Ok(WasmInstrI64LtS),
      0x54S => Ok(WasmInstrI64LtU),
      0x55S => Ok(WasmInstrI64GtS),
      0x56S => Ok(WasmInstrI64GtU),
      0x57S => Ok(WasmInstrI64LeS),
      0x58S => Ok(WasmInstrI64LeU),
      0x59S => Ok(WasmInstrI64GeS),
      0x5AS => Ok(WasmInstrI64GeU),
      0x5BS => Ok(WasmInstrF32Eq),
      0x5CS => Ok(WasmInstrF32Ne),
      0x5DS => Ok(WasmInstrF32Lt),
      0x5ES => Ok(WasmInstrF32Gt),
      0x5FS => Ok(WasmInstrF32Le),
      0x60S => Ok(WasmInstrF32Ge),
      0x61S => Ok(WasmInstrF64Eq),
      0x62S => Ok(WasmInstrF64Ne),
      0x63S => Ok(WasmInstrF64Lt),
      0x64S => Ok(WasmInstrF64Gt),
      0x65S => Ok(WasmInstrF64Le),
      0x66S => Ok(WasmInstrF64Ge),
      0x67S => Ok(WasmInstrI32Clz),
      0x68S => Ok(WasmInstrI32Ctz),
      0x69S => Ok(WasmInstrI32Popcnt),
      0x6AS => Ok(WasmInstrI32Add),
      0x6BS => Ok(WasmInstrI32Sub),
      0x6CS => Ok(WasmInstrI32Mul),
      0x6DS => Ok(WasmInstrI32DivS),
      0x6ES => Ok(WasmInstrI32DivU),
      0x6FS => Ok(WasmInstrI32RemS),
      0x70S => Ok(WasmInstrI32RemU),
      0x71S => Ok(WasmInstrI32And),
      0x72S => Ok(WasmInstrI32Or),
      0x73S => Ok(WasmInstrI32Xor),
      0x74S => Ok(WasmInstrI32Shl),
      0x75S => Ok(WasmInstrI32ShrS),
      0x76S => Ok(WasmInstrI32ShrU),
      0x77S => Ok(WasmInstrI32Rotl),
      0x78S => Ok(WasmInstrI32Rotr),
      0x79S => Ok(WasmInstrI64Clz),
      0x7AS => Ok(WasmInstrI64Ctz),
      0x7BS => Ok(WasmInstrI64Popcnt),
      0x7CS => Ok(WasmInstrI64Add),
      0x7DS => Ok(WasmInstrI64Sub),
      0x7ES => Ok(WasmInstrI64Mul),
      0x7FS => Ok(WasmInstrI64DivS),
      0x80S => Ok(WasmInstrI64DivU),
      0x81S => Ok(WasmInstrI64RemS),
      0x82S => Ok(WasmInstrI64RemU),
      0x83S => Ok(WasmInstrI64And),
      0x84S => Ok(WasmInstrI64Or),
      0x85S => Ok(WasmInstrI64Xor),
      0x86S => Ok(WasmInstrI64Shl),
      0x87S => Ok(WasmInstrI64ShrS),
      0x88S => Ok(WasmInstrI64ShrU),
      0x89S => Ok(WasmInstrI64Rotl),
      0x8AS => Ok(WasmInstrI64Rotr),
      0x8BS => Ok(WasmInstrF32Abs),
      0x8CS => Ok(WasmInstrF32Neg),
      0x8DS => Ok(WasmInstrF32Ceil),
      0x8ES => Ok(WasmInstrF32Floor),
      0x8FS => Ok(WasmInstrF32Trunc),
      0x90S => Ok(WasmInstrF32Nearest),
      0x91S => Ok(WasmInstrF32Sqrt),
      0x92S => Ok(WasmInstrF32Add),
      0x93S => Ok(WasmInstrF32Sub),
      0x94S => Ok(WasmInstrF32Mul),
      0x95S => Ok(WasmInstrF32Div),
      0x96S => Ok(WasmInstrF32Min),
      0x97S => Ok(WasmInstrF32Max),
      0x98S => Ok(WasmInstrF32CopySign),
      0x99S => Ok(WasmInstrF64Abs),
      0x9AS => Ok(WasmInstrF64Neg),
      0x9BS => Ok(WasmInstrF64Ceil),
      0x9CS => Ok(WasmInstrF64Floor),
      0x9DS => Ok(WasmInstrF64Trunc),
      0x9ES => Ok(WasmInstrF64Nearest),
      0x9FS => Ok(WasmInstrF64Sqrt),
      0xA0S => Ok(WasmInstrF64Add),
      0xA1S => Ok(WasmInstrF64Sub),
      0xA2S => Ok(WasmInstrF64Mul),
      0xA3S => Ok(WasmInstrF64Div),
      0xA4S => Ok(WasmInstrF64Min),
      0xA5S => Ok(WasmInstrF64Max),
      0xA6S => Ok(WasmInstrF64CopySign),
      0xA7S => Ok(WasmInstrI32WrapI64),
      0xA8S => Ok(WasmInstrI32TruncF32S),
      0xA9S => Ok(WasmInstrI32TruncF32U),
      0xAAS => Ok(WasmInstrI32TruncF64S),
      0xABS => Ok(WasmInstrI32TruncF64U),
      0xACS => Ok(WasmInstrI64ExtendI32S),
      0xADS => Ok(WasmInstrI64ExtendI32U),
      0xAES => Ok(WasmInstrI64TruncF32S),
      0xAFS => Ok(WasmInstrI64TruncF32U),
      0xB0S => Ok(WasmInstrI64TruncF64S),
      0xB1S => Ok(WasmInstrI64TruncF64U),
      0xB2S => Ok(WasmInstrF32ConvertI32S),
      0xB3S => Ok(WasmInstrF32ConvertI32U),
      0xB4S => Ok(WasmInstrF32ConvertI64S),
      0xB5S => Ok(WasmInstrF32ConvertI64U),
      0xB6S => Ok(WasmInstrF32DemoteF64),
      0xB7S => Ok(WasmInstrF64ConvertI32S),
      0xB8S => Ok(WasmInstrF64ConvertI32U),
      0xB9S => Ok(WasmInstrF64ConvertI64S),
      0xBAS => Ok(WasmInstrF64ConvertI64U),
      0xBBS => Ok(WasmInstrF64PromoteF32),
      0xBCS => Ok(WasmInstrI32ReinterpretF32),
      0xBDS => Ok(WasmInstrI64ReinterpretF64),
      0xBES => Ok(WasmInstrF32ReinterpretI32),
      0xBFS => Ok(WasmInstrF64ReinterpretI64),
      0xC0S => Ok(WasmInstrI32Extend8S),
      0xC1S => Ok(WasmInstrI32Extend16S),
      0xC2S => Ok(WasmInstrI64Extend8S),
      0xC3S => Ok(WasmInstrI64Extend16S),
      0xC4S => Ok(WasmInstrI64Extend32S),
      // TODO: Vector Instructions
      // 0xFC leading
      0xFCS => {
        let instrIndex = getUleb128AndAdvance(parserState, 32)
        match (instrIndex) {
          // Table Instructions
          12 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrTableInit(elemIndex, tableIndex))
          },
          13 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrElemDrop(elemIndex))
          },
          14 => {
            let tableIndex1 = getUleb128AndAdvance(parserState, 32)
            let tableIndex2 = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrTableCopy(tableIndex1, tableIndex2))
          },
          15 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrTableGrow(tableIndex))
          },
          16 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrTableSize(tableIndex))
          },
          17 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrTableFill(tableIndex))
          },
          // Memory Instructions
          8 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstrMemoryInit(dataIndex))
          },
          9 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstrDataDrop(dataIndex))
          },
          10 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstrMemoryCopy)
          },
          11 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstrMemoryFill)
          },
          // Numeric Instructions
          0 => Ok(WasmInstrI32TruncSatF32S),
          1 => Ok(WasmInstrI32TruncSatF32U),
          2 => Ok(WasmInstrI32TruncSatF64S),
          3 => Ok(WasmInstrI32TruncSatF64U),
          4 => Ok(WasmInstrI64TruncSatF32S),
          5 => Ok(WasmInstrI64TruncSatF32U),
          6 => Ok(WasmInstrI64TruncSatF64S),
          7 => Ok(WasmInstrI64TruncSatF64U),
          // Invalid
          _ =>
            buildUnexpectedWasmTokenCustom(
              parserState,
              "0-17",
              toString(instrIndex)
            ),
        }
      },
      // End Instruction
      0x05S => Ok(WasmInstrElse),
      0x0BS => Ok(WasmInstrEnd),
      // Invalid
      c => Err(InvalidWasmInstr(c)),
    }
  },
  parseExpr = (parserState, parent) => {
    let mut exprs = []
    while (!isAtEndOfInput(parserState)) {
      let instr = parseInstr(parserState)
      match (instr) {
        Ok(instr) => {
          exprs = [instr, ...exprs]
          if (instr == WasmInstrEnd) break
        },
        Err(err) => return Err(err),
      }
    }
    return Ok(List.reverse(exprs))
  }
  provide let parseSection = section => {
    // Match The Section
    let section = match (section) {
      RawCustomSection(bytes) => CustomSection(bytes),
      RawTypeSection(bytes) => {
        let parserState = makeParser(bytes)
        // This Contains Function Types
        let typeCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Function Types
        let mut functionTypes = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let functionType = parseFunctionType(parserState)
          match (functionType) {
            Ok(functionType) => {
              functionTypes = [functionType, ...functionTypes]
              void
            },
            Err(err) => return Err(err),
          }
        }
        TypeSection(List.reverse(functionTypes))
      },
      RawImportSection(bytes) => {
        let parserState = makeParser(bytes)
        let importCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Import Types
        let mut wasmImports = []
        for (let mut i = 0; i < importCount; i += 1) {
          let wasmImport = parseWasmImport(parserState)
          match (wasmImport) {
            Ok(wasmImport) => {
              wasmImports = [wasmImport, ...wasmImports]
              void
            },
            Err(err) => return Err(err),
          }
        }
        ImportSection(List.reverse(wasmImports))
      },
      RawFunctionSection(bytes) => {
        let parserState = makeParser(bytes)
        let funcCount = getUleb128AndAdvance(parserState, 32)
        let mut funcTypes = []
        for (let mut i = 0; i < funcCount; i += 1) {
          let funcType = getUleb128AndAdvance(parserState, 32)
          funcTypes = [funcType, ...funcTypes]
        }
        FunctionSection(List.reverse(funcTypes))
      },
      RawTableSection(bytes) => {
        let parserState = makeParser(bytes)
        let tableCount = getUleb128AndAdvance(parserState, 32)
        let mut tableTypes = []
        for (let mut i = 0; i < tableCount; i += 1) {
          let tableType = match (parseTableType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          tableTypes = [tableType, ...tableTypes]
        }
        TableSection(List.reverse(tableTypes))
      },
      RawMemorySection(bytes) => {
        let parserState = makeParser(bytes)
        let memCount = getUleb128AndAdvance(parserState, 32)
        let mut memTypes = []
        for (let mut i = 0; i < memCount; i += 1) {
          let (minLimit, maxLimit) = match (parseLimits(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          memTypes = [(minLimit, maxLimit), ...memTypes]
        }
        MemorySection(List.reverse(memTypes))
      },
      RawGlobalSection(bytes) => {
        let parserState = makeParser(bytes)
        let globalCount = getUleb128AndAdvance(parserState, 32)
        let mut globalTypes = []
        for (let mut i = 0; i < globalCount; i += 1) {
          let globalType = match (parseGlobalType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          let globalValue = match (parseExpr(parserState, ParentGlobal)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          globalTypes = [(globalType, globalValue), ...globalTypes]
        }
        GlobalSection(List.reverse(globalTypes))
      },
      RawExportSection(bytes) => {
        let parserState = makeParser(bytes)
        let exportCount = getUleb128AndAdvance(parserState, 32)
        let mut exports = []
        for (let mut i = 0; i < exportCount; i += 1) {
          // Parse Export Name
          let name = getStringAndAdvance(parserState)
          nextByteU(parserState)
          // Parse Export Description
          let exportDescType = parserState.currentByte
          nextByteU(parserState)
          let idx = getUleb128AndAdvance(parserState, 32)
          let exportDesc = match (exportDescType) {
            0x00S => FuncExport(idx),
            0x01S => TableExport(idx),
            0x02S => MemoryExport(idx),
            0x03S => GlobalExport(idx),
            c => return Err(InvalidExportDescription(c)),
          }
          exports = [{ name, exportDesc }: WasmExportType, ...exports]
        }
        ExportSection(List.reverse(exports))
      },
      RawStartSection(bytes) => {
        let parserState = makeParser(bytes)
        let startIdx = getUleb128AndAdvance(parserState, 32)
        StartSection(startIdx)
      },
      RawElementSection(bytes) => {
        // TODO: Parse Element Section
        ElementSection(void)
      },
      RawDataCountSection(bytes) => {
        let parserState = makeParser(bytes)
        let dataCount = getUleb128AndAdvance(parserState, 32)
        DataCountSection(dataCount)
      },
      RawCodeSection(bytes) => {
        let parserState = makeParser(bytes)
        let codeCount = getUleb128AndAdvance(parserState, 32)
        let mut functions = []
        for (let mut i = 0; i < codeCount; i += 1) {
          // Get Function Size
          let funcSize = getUleb128AndAdvance(parserState, 32)
          // Get Function Locals
          let localCount = getUleb128AndAdvance(parserState, 32)
          let mut locals = []
          for (let mut j = 0; j < localCount; j += 1) {
            let localTypeCount = getUleb128AndAdvance(parserState, 32)
            let localType = match (parseWasmType(parserState)) {
              Ok(t) => t,
              Err(e) => return Err(e),
            }
            locals = [
              { wasmType: localType, count: localTypeCount }: WasmLocalType,
              ...locals
            ]
          }
          // Parse The Function Body
          let wasmBody = match (parseExpr(parserState, ParentFunction)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          // Add To List
          functions = [
            { locals: List.reverse(locals), body: wasmBody }: WasmFunctionType,
            ...functions
          ]
        }
        CodeSection(List.reverse(functions))
      },
      RawDataSection(bytes) => {
        // TODO: Parse Data Section
        DataSection(void)
      },
    }
    // Return
    return Ok(section)
  }
}
// Builder
