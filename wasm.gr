module Wasm

include "Bytes"
include "Buffer"
include "Int16"
include "int64"
include "Uint8"
include "list"
include "string"
include "float32"
include "float64"
include "runtime/numberUtils"
include "runtime/numbers"
include "runtime/dataStructures"
include "runtime/debugPrint"
include "runtime/unsafe/wasmi32"
include "runtime/unsafe/wasmi64"
include "runtime/unsafe/wasmf32"
include "runtime/unsafe/wasmf64"
from Numbers use { coerceNumberToWasmI32 }
from DataStructures use { tagInt16, newInt64, newFloat32, newFloat64 }
// Types
// TODO: Put The Types Directly Related To Parsing Under Parsing Module
/**
 * Represents errors for Wasm parsing.
 */
provide enum WasmParseError {
  UnexpectedWasmToken(String),
  InvalidWasmType(Int16),
  InvalidImportDescType(Int16),
  InvalidWasmLimitType(Int16),
  InvalidWasmGlobal,
  InvalidExportDescription(Int16),
  InvalidWasmInstr(Int16),
  UnexpectedEndOfInput,
}
enum Parent {
  ParentFunction,
  ParentGlobal,
  ParentElement,
  ParentBlock,
  ParentData,
}
/**
 * Represents raw unparsed wasm sections.
 */
provide enum RawSections {
  RawCustomSection(Bytes),
  RawTypeSection(Bytes),
  RawImportSection(Bytes),
  RawFunctionSection(Bytes),
  RawTableSection(Bytes),
  RawMemorySection(Bytes),
  RawGlobalSection(Bytes),
  RawExportSection(Bytes),
  RawStartSection(Bytes),
  RawElementSection(Bytes),
  RawDataCountSection(Bytes),
  RawCodeSection(Bytes),
  RawDataSection(Bytes),
}
/**
 * Represents wasm export descriptions
 */
provide enum WasmExportDesc {
  FuncExport(Number),
  TableExport(Number),
  MemoryExport(Number),
  GlobalExport(Number),
}
/**
 * Represents wasm memory argument
 */
provide record WasmMemoryArg {
  align: Number,
  offset: Number,
}
enum WasmTypeDesc {
  AllType,
  FuncType,
  NumType,
  VecType,
  RefType,
}
/**
 * Represents wasm primitive types.
 */
provide enum WasmType {
  // FuncType
  WasmFuncType(List<WasmType>, List<WasmType>),
  // NumberType
  WasmI32,
  WasmI64,
  WasmF32,
  WasmF64,
  // VectorType
  WasmV128,
  // RefType
  WasmFuncRef,
  WasmExternRef,
  // Special
  EmptyType,
  TypeIdx(Number),
}
/**
 * Represents wasm instructions and corresponding data.
 */
provide enum WasmInstr {
  // Control Instructions
  WasmInstr_Unreachable,
  WasmInstr_Nop,
  WasmInstr_Block(WasmType, Expression),
  WasmInstr_Loop(WasmType, Expression),
  WasmInstr_If(WasmType, Expression),
  WasmInstr_If_Else(WasmType, Expression, Expression),
  WasmInstr_Br(Number),
  WasmInstr_Br_If(Number),
  WasmInstr_Br_Table(List<Number>, Number),
  WasmInstr_Return,
  WasmInstr_Call(Number),
  WasmInstr_Call_Indirect(Number, Number),
  WasmInstr_Return_Call(Number),
  WasmInstr_Return_Call_Indirect(Number, Number),
  // Reference Instructions
  WasmInstr_Ref_Null(WasmType),
  WasmInstr_Ref_Is_Null,
  WasmInstr_Ref_Func(Number),
  // Parametric Instructions
  WasmInstr_Drop,
  WasmInstr_Select(Option<List<WasmType>>),
  // Variable Instructions
  WasmInstr_Local_Get(Number),
  WasmInstr_Local_Set(Number),
  WasmInstr_Local_Tee(Number),
  WasmInstr_Global_Get(Number),
  WasmInstr_Global_Set(Number),
  // Table Instructions
  WasmInstr_Table_Get(Number),
  WasmInstr_Table_Set(Number),
  WasmInstr_Table_Init(Number, Number),
  WasmInstr_Elem_Drop(Number),
  WasmInstr_Table_Copy(Number, Number),
  WasmInstr_Table_Grow(Number),
  WasmInstr_Table_Size(Number),
  WasmInstr_Table_Fill(Number),
  // Memory Instructions
  WasmInstr_I32_Load(WasmMemoryArg),
  WasmInstr_I64_Load(WasmMemoryArg),
  WasmInstr_F32_Load(WasmMemoryArg),
  WasmInstr_F64_Load(WasmMemoryArg),
  WasmInstr_I32_Load8_S(WasmMemoryArg),
  WasmInstr_I32_Load8_U(WasmMemoryArg),
  WasmInstr_I32_Load16_S(WasmMemoryArg),
  WasmInstr_I32_Load16_U(WasmMemoryArg),
  WasmInstr_I64_Load8_S(WasmMemoryArg),
  WasmInstr_I64_Load8_U(WasmMemoryArg),
  WasmInstr_I64_Load16_S(WasmMemoryArg),
  WasmInstr_I64_Load16_U(WasmMemoryArg),
  WasmInstr_I64_Load32_S(WasmMemoryArg),
  WasmInstr_I64_Load32_U(WasmMemoryArg),
  WasmInstr_I32_Store(WasmMemoryArg),
  WasmInstr_I64_Store(WasmMemoryArg),
  WasmInstr_F32_Store(WasmMemoryArg),
  WasmInstr_F64_Store(WasmMemoryArg),
  WasmInstr_I32_Store8(WasmMemoryArg),
  WasmInstr_I32_Store16(WasmMemoryArg),
  WasmInstr_I64_Store8(WasmMemoryArg),
  WasmInstr_I64_Store16(WasmMemoryArg),
  WasmInstr_I64_Store32(WasmMemoryArg),
  WasmInstr_Memory_Size,
  WasmInstr_Memory_Grow,
  WasmInstr_Memory_Init(Number),
  WasmInstr_Data_Drop(Number),
  WasmInstr_Memory_Copy,
  WasmInstr_Memory_Fill,
  // Numeric Instructions
  WasmInstr_I32_Const(Number),
  WasmInstr_I64_Const(Number),
  WasmInstr_F32_Const(Number),
  WasmInstr_F64_Const(Number),
  WasmInstr_I32_Eqz,
  WasmInstr_I32_Eq,
  WasmInstr_I32_Ne,
  WasmInstr_I32_Lt_S,
  WasmInstr_I32_Lt_U,
  WasmInstr_I32_Gt_S,
  WasmInstr_I32_Gt_U,
  WasmInstr_I32_Le_S,
  WasmInstr_I32_Le_U,
  WasmInstr_I32_Ge_S,
  WasmInstr_I32_Ge_U,
  WasmInstr_I64_Eqz,
  WasmInstr_I64_Eq,
  WasmInstr_I64_Ne,
  WasmInstr_I64_Lt_S,
  WasmInstr_I64_Lt_U,
  WasmInstr_I64_Gt_S,
  WasmInstr_I64_Gt_U,
  WasmInstr_I64_Le_S,
  WasmInstr_I64_Le_U,
  WasmInstr_I64_Ge_S,
  WasmInstr_I64_Ge_U,
  WasmInstr_F32_Eq,
  WasmInstr_F32_Ne,
  WasmInstr_F32_Lt,
  WasmInstr_F32_Gt,
  WasmInstr_F32_Le,
  WasmInstr_F32_Ge,
  WasmInstr_F64_Eq,
  WasmInstr_F64_Ne,
  WasmInstr_F64_Lt,
  WasmInstr_F64_Gt,
  WasmInstr_F64_Le,
  WasmInstr_F64_Ge,
  WasmInstr_I32_Clz,
  WasmInstr_I32_Ctz,
  WasmInstr_I32_Popcnt,
  WasmInstr_I32_Add,
  WasmInstr_I32_Sub,
  WasmInstr_I32_Mul,
  WasmInstr_I32_Div_S,
  WasmInstr_I32_Div_U,
  WasmInstr_I32_Rem_S,
  WasmInstr_I32_Rem_U,
  WasmInstr_I32_And,
  WasmInstr_I32_Or,
  WasmInstr_I32_Xor,
  WasmInstr_I32_Shl,
  WasmInstr_I32_Shr_S,
  WasmInstr_I32_Shr_U,
  WasmInstr_I32_Rotl,
  WasmInstr_I32_Rotr,
  WasmInstr_I64_Clz,
  WasmInstr_I64_Ctz,
  WasmInstr_I64_Popcnt,
  WasmInstr_I64_Add,
  WasmInstr_I64_Sub,
  WasmInstr_I64_Mul,
  WasmInstr_I64_Div_S,
  WasmInstr_I64_Div_U,
  WasmInstr_I64_Rem_S,
  WasmInstr_I64_Rem_U,
  WasmInstr_I64_And,
  WasmInstr_I64_Or,
  WasmInstr_I64_Xor,
  WasmInstr_I64_Shl,
  WasmInstr_I64_Shr_S,
  WasmInstr_I64_Shr_U,
  WasmInstr_I64_Rotl,
  WasmInstr_I64_Rotr,
  WasmInstr_F32_Abs,
  WasmInstr_F32_Neg,
  WasmInstr_F32_Ceil,
  WasmInstr_F32_Floor,
  WasmInstr_F32_Trunc,
  WasmInstr_F32_Nearest,
  WasmInstr_F32_Sqrt,
  WasmInstr_F32_Add,
  WasmInstr_F32_Sub,
  WasmInstr_F32_Mul,
  WasmInstr_F32_Div,
  WasmInstr_F32_Min,
  WasmInstr_F32_Max,
  WasmInstr_F32_CopySign,
  WasmInstr_F64_Abs,
  WasmInstr_F64_Neg,
  WasmInstr_F64_Ceil,
  WasmInstr_F64_Floor,
  WasmInstr_F64_Trunc,
  WasmInstr_F64_Nearest,
  WasmInstr_F64_Sqrt,
  WasmInstr_F64_Add,
  WasmInstr_F64_Sub,
  WasmInstr_F64_Mul,
  WasmInstr_F64_Div,
  WasmInstr_F64_Min,
  WasmInstr_F64_Max,
  WasmInstr_F64_CopySign,
  WasmInstr_I32_Wrap_I64,
  WasmInstr_I32_Trunc_F32_S,
  WasmInstr_I32_Trunc_F32_U,
  WasmInstr_I32_Trunc_F64_S,
  WasmInstr_I32_Trunc_F64_U,
  WasmInstr_I64_Extend_I32_S,
  WasmInstr_I64_Extend_I32_U,
  WasmInstr_I64_Trunc_F32_S,
  WasmInstr_I64_Trunc_F32_U,
  WasmInstr_I64_Trunc_F64_S,
  WasmInstr_I64_Trunc_F64_U,
  WasmInstr_F32_Convert_I32_S,
  WasmInstr_F32_Convert_I32_U,
  WasmInstr_F32_Convert_I64_S,
  WasmInstr_F32_Convert_I64_U,
  WasmInstr_F32_Demote_F64,
  WasmInstr_F64_Convert_I32_S,
  WasmInstr_F64_Convert_I32_U,
  WasmInstr_F64_Convert_I64_S,
  WasmInstr_F64_Convert_I64_U,
  WasmInstr_F64_Promote_F32,
  WasmInstr_I32_Reinterpret_F32,
  WasmInstr_I64_Reinterpret_F64,
  WasmInstr_F32_Reinterpret_I32,
  WasmInstr_F64_Reinterpret_I64,
  WasmInstr_I32_Extend8_S,
  WasmInstr_I32_Extend16_S,
  WasmInstr_I64_Extend8_S,
  WasmInstr_I64_Extend16_S,
  WasmInstr_I64_Extend32_S,
  WasmInstr_I32_TruncSat_F32_S,
  WasmInstr_I32_TruncSat_F32_U,
  WasmInstr_I32_TruncSat_F64_S,
  WasmInstr_I32_TruncSat_F64_U,
  WasmInstr_I64_TruncSat_F32_S,
  WasmInstr_I64_TruncSat_F32_U,
  WasmInstr_I64_TruncSat_F64_S,
  WasmInstr_I64_TruncSat_F64_U,
  // Vector Instructions
  WasmInstr_V128_Load(WasmMemoryArg),
  WasmInstr_V128_8x8_Load_S(WasmMemoryArg),
  WasmInstr_V128_8x8_Load_U(WasmMemoryArg),
  WasmInstr_V128_16x4_Load_S(WasmMemoryArg),
  WasmInstr_V128_16x4_Load_U(WasmMemoryArg),
  WasmInstr_V128_32x2_Load_S(WasmMemoryArg),
  WasmInstr_V128_32x2_Load_U(WasmMemoryArg),
  WasmInstr_V128_Load_8_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_16_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_32_Splat(WasmMemoryArg),
  WasmInstr_V128_Load_64_Splat(WasmMemoryArg),
  WasmInstr_Load_32_Zero(WasmMemoryArg),
  WasmInstr_Load_64_Zero(WasmMemoryArg),
  WasmInstr_V128_Store(WasmMemoryArg),
  WasmInstr_V128_Load8_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load16_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load32_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Load64_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store8_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store16_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store32_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Store64_Lane(WasmMemoryArg, Number),
  WasmInstr_V128_Const(Number),
  WasmInstr_I8x16_Shuffle(
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8,
    Uint8
  ),
  WasmInstr_I8x16_Extract_Lane_S(Number),
  WasmInstr_I8x16_Extract_Lane_U(Number),
  WasmInstr_I8x16_Replace_Lane(Number),
  WasmInstr_I16x8_Extract_Lane_S(Number),
  WasmInstr_I16x8_Extract_Lane_U(Number),
  WasmInstr_I16x8_Replace_Lane(Number),
  WasmInstr_I32x4_Extract_Lane(Number),
  WasmInstr_I32x4_Replace_Lane(Number),
  WasmInstr_I64x2_Extract_Lane(Number),
  WasmInstr_I64x2_Replace_Lane(Number),
  WasmInstr_F32x4_Extract_Lane(Number),
  WasmInstr_F32x4_Replace_Lane(Number),
  WasmInstr_F64x2_Extract_Lane(Number),
  WasmInstr_F64x2_Replace_Lane(Number),
  WasmInstr_I8x16_Swizzle,
  WasmInstr_I8x16_Splat,
  WasmInstr_I16x8_Splat,
  WasmInstr_I32x4_Splat,
  WasmInstr_I64x2_Splat,
  WasmInstr_F32x4_Splat,
  WasmInstr_F64x2_Splat,
  WasmInstr_I8x16_Eq,
  WasmInstr_I8x16_Ne,
  WasmInstr_I8x16_Lt_S,
  WasmInstr_I8x16_Lt_U,
  WasmInstr_I8x16_Gt_S,
  WasmInstr_I8x16_Gt_U,
  WasmInstr_I8x16_Le_S,
  WasmInstr_I8x16_Le_U,
  WasmInstr_I8x16_Ge_S,
  WasmInstr_I8x16_Ge_U,
  WasmInstr_I16x8_Eq,
  WasmInstr_I16x8_Ne,
  WasmInstr_I16x8_Lt_S,
  WasmInstr_I16x8_Lt_U,
  WasmInstr_I16x8_Gt_S,
  WasmInstr_I16x8_Gt_U,
  WasmInstr_I16x8_Le_S,
  WasmInstr_I16x8_Le_U,
  WasmInstr_I16x8_Ge_S,
  WasmInstr_I16x8_Ge_U,
  WasmInstr_I32x4_Eq,
  WasmInstr_I32x4_Ne,
  WasmInstr_I32x4_Lt_S,
  WasmInstr_I32x4_Lt_U,
  WasmInstr_I32x4_Gt_S,
  WasmInstr_I32x4_Gt_U,
  WasmInstr_I32x4_Le_S,
  WasmInstr_I32x4_Le_U,
  WasmInstr_I32x4_Ge_S,
  WasmInstr_I32x4_Ge_U,
  WasmInstr_I64x2_Eq,
  WasmInstr_I64x2_Ne,
  WasmInstr_I64x2_Lt_S,
  WasmInstr_I64x2_Gt_S,
  WasmInstr_I64x2_Le_S,
  WasmInstr_I64x2_Ge_S,
  WasmInstr_F32x4_Eq,
  WasmInstr_F32x4_Ne,
  WasmInstr_F32x4_Lt,
  WasmInstr_F32x4_Gt,
  WasmInstr_F32x4_Le,
  WasmInstr_F32x4_Ge,
  WasmInstr_F64x2_Eq,
  WasmInstr_F64x2_Ne,
  WasmInstr_F64x2_Lt,
  WasmInstr_F64x2_Gt,
  WasmInstr_F64x2_Le,
  WasmInstr_F64x2_Ge,
  WasmInstr_V128_Not,
  WasmInstr_V128_And,
  WasmInstr_V128_And_Not,
  WasmInstr_V128_Or,
  WasmInstr_V128_Xor,
  WasmInstr_V128_Bitselect,
  WasmInstr_V128_Any_True,
  WasmInstr_I8x16_Abs,
  WasmInstr_I8x16_Neg,
  WasmInstr_I8x16_Popcnt,
  WasmInstr_I8x16_All_True,
  WasmInstr_I8x16_Bitmask,
  WasmInstr_I8x16_Narrow_I16x8_S,
  WasmInstr_I8x16_Narrow_I16x8_U,
  WasmInstr_I8x16_Shl,
  WasmInstr_I8x16_Shr_S,
  WasmInstr_I8x16_Shr_U,
  WasmInstr_I8x16_Add,
  WasmInstr_I8x16_Add_Sat_S,
  WasmInstr_I8x16_Add_Sat_U,
  WasmInstr_I8x16_Sub,
  WasmInstr_I8x16_Sub_Sat_S,
  WasmInstr_I8x16_Sub_Sat_U,
  WasmInstr_I8x16_Min_S,
  WasmInstr_I8x16_Min_U,
  WasmInstr_I8x16_Max_S,
  WasmInstr_I8x16_Max_U,
  WasmInstr_I8x16_Avgr_U,
  WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_S,
  WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_U,
  WasmInstr_I16x8_Abs,
  WasmInstr_I16x8_Neg,
  WasmInstr_I16x8_q15mulr_sat_s,
  WasmInstr_I16x8_All_True,
  WasmInstr_I16x8_Bitmask,
  WasmInstr_I16x8_Narrow_I32x4_S,
  WasmInstr_I16x8_Narrow_I32x4_U,
  WasmInstr_I16x8_Extend_Low_I8x16_S,
  WasmInstr_I16x8_Extend_High_I8x16_S,
  WasmInstr_I16x8_Extend_Low_I8x16_U,
  WasmInstr_I16x8_Extend_High_I8x16_U,
  WasmInstr_I16x8_Shl,
  WasmInstr_I16x8_Shr_S,
  WasmInstr_I16x8_Shr_U,
  WasmInstr_I16x8_Add,
  WasmInstr_I16x8_Add_Sat_S,
  WasmInstr_I16x8_Add_Sat_U,
  WasmInstr_I16x8_Sub,
  WasmInstr_I16x8_Sub_Sat_S,
  WasmInstr_I16x8_Sub_Sat_U,
  WasmInstr_I16x8_Mul,
  WasmInstr_I16x8_Min_S,
  WasmInstr_I16x8_Min_U,
  WasmInstr_I16x8_Max_S,
  WasmInstr_I16x8_Max_U,
  WasmInstr_I16x8_Avgr_U,
  WasmInstr_I16x8_ExtMulLow_I8x16_S,
  WasmInstr_I16x8_ExtMulHigh_I8x16_S,
  WasmInstr_I16x8_ExtMulLow_I8x16_U,
  WasmInstr_I16x8_ExtMulHigh_I8x16_U,
  WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_S,
  WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_U,
  WasmInstr_I32x4_Abs,
  WasmInstr_I32x4_Neg,
  WasmInstr_I32x4_All_True,
  WasmInstr_I32x4_Bitmask,
  WasmInstr_I32x4_Extend_Low_I16x8_S,
  WasmInstr_I32x4_Extend_High_I16x8_S,
  WasmInstr_I32x4_Extend_Low_I16x8_U,
  WasmInstr_I32x4_Extend_High_I16x8_U,
  WasmInstr_I32x4_Shl,
  WasmInstr_I32x4_Shr_S,
  WasmInstr_I32x4_Shr_U,
  WasmInstr_I32x4_Add,
  WasmInstr_I32x4_Sub,
  WasmInstr_I32x4_Mul,
  WasmInstr_I32x4_Min_S,
  WasmInstr_I32x4_Min_U,
  WasmInstr_I32x4_Max_S,
  WasmInstr_I32x4_Max_U,
  WasmInstr_I32x4_Dot_I16x8_S,
  WasmInstr_I32x4_ExtMulLow_I16x8_S,
  WasmInstr_I32x4_ExtMulHigh_I16x8_S,
  WasmInstr_I32x4_ExtMulLow_I16x8_U,
  WasmInstr_I32x4_ExtMulHigh_I16x8_U,
  WasmInstr_I64x2_Abs,
  WasmInstr_I64x2_Neg,
  WasmInstr_I64x2_All_True,
  WasmInstr_I64x2_Bitmask,
  WasmInstr_I64x2_Extend_Low_I32x4_S,
  WasmInstr_I64x2_Extend_High_I32x4_S,
  WasmInstr_I64x2_Extend_Low_I32x4_U,
  WasmInstr_I64x2_Extend_High_I32x4_U,
  WasmInstr_I64x2_Shl,
  WasmInstr_I64x2_Shr_S,
  WasmInstr_I64x2_Shr_U,
  WasmInstr_I64x2_Add,
  WasmInstr_I64x2_Sub,
  WasmInstr_I64x2_Mul,
  WasmInstr_I64x2_ExtMulLow_I32x4_S,
  WasmInstr_I64x2_ExtMulHigh_I32x4_S,
  WasmInstr_I64x2_ExtMulLow_I32x4_U,
  WasmInstr_I64x2_ExtMulHigh_I32x4_U,
  WasmInstr_F32x4_Ceil,
  WasmInstr_F32x4_Floor,
  WasmInstr_F32x4_Trunc,
  WasmInstr_F32x4_Nearest,
  WasmInstr_F32x4_Abs,
  WasmInstr_F32x4_Neg,
  WasmInstr_F32x4_Sqrt,
  WasmInstr_F32x4_Add,
  WasmInstr_F32x4_Sub,
  WasmInstr_F32x4_Mul,
  WasmInstr_F32x4_Div,
  WasmInstr_F32x4_Min,
  WasmInstr_F32x4_Max,
  WasmInstr_F32x4_Pmin,
  WasmInstr_F32x4_Pmax,
  WasmInstr_F64x2_Ceil,
  WasmInstr_F64x2_Floor,
  WasmInstr_F64x2_Trunc,
  WasmInstr_F64x2_Nearest,
  WasmInstr_F64x2_Abs,
  WasmInstr_F64x2_Neg,
  WasmInstr_F64x2_Sqrt,
  WasmInstr_F64x2_Add,
  WasmInstr_F64x2_Sub,
  WasmInstr_F64x2_Mul,
  WasmInstr_F64x2_Div,
  WasmInstr_F64x2_Min,
  WasmInstr_F64x2_Max,
  WasmInstr_F64x2_Pmin,
  WasmInstr_F64x2_Pmax,
  WasmInstr_I32x4_Trunc_Sat_F32x4_S,
  WasmInstr_I32x4_Trunc_Sat_F32x4_U,
  WasmInstr_F32x4_Convert_I32x4_S,
  WasmInstr_F32x4_Convert_I32x4_U,
  WasmInstr_I32x4_Trunc_Sat_F64x2_S_Zero,
  WasmInstr_I32x4_Trunc_Sat_F64x2_U_Zero,
  WasmInstr_F64x2_ConvertLow_I32x4_S,
  WasmInstr_F64x2_ConvertLow_I32x4_U,
  WasmInstr_F32x4_Demote_F64x2_Zero,
  WasmInstr_F64x2_PromoteLow_F32x4,
  // End
  WasmInstr_Else,
  WasmInstr_End,
}
/**
 * Represents a wasm Expression.
 */
and provide type Expression = List<WasmInstr>
/**
 * Represents a wasm table.
 */
provide record WasmTableType {
  wasmType: WasmType,
  minLimit: Number,
  maxLimit: Option<Number>,
}
/**
 * Represents a wasm global.
 */
provide record WasmGlobalType {
  wasmType: WasmType,
  isMutable: Bool,
}
/**
 * Represents a wasm export.
 */
provide record WasmExportType {
  name: String,
  exportDesc: WasmExportDesc,
}
/**
 * Represents a wasm local.
 */
provide record WasmLocalType {
  wasmType: WasmType,
  count: Number,
}
/**
 * Represents a wasm function.
 */
provide record WasmFunctionType {
  locals: List<WasmLocalType>,
  body: Expression,
}
/**
 * Represents a wasm elements mode.
 */
provide enum WasmElemMode {
  ElemPassive,
  ElemActive{
    tableIdx: Number,
    offset: Expression,
  },
  ElemDeclarative,
}
/**
 * Represents a wasm element segment.
 */
provide record WasmElementSegment {
  wasmType: WasmType,
  contents: List<Expression>,
  elemMode: WasmElemMode,
}
/**
 * Represents a wasm data segment.
 */
provide enum WasmDataSegment {
  DataActive{
    memIdx: Number,
    offset: Expression,
    content: Bytes,
  },
  DataPassive{
    content: Bytes,
  },
}
/**
 * Represents a wasm import description.
 */
provide enum WasmImportDesc {
  WasmFuncImportDesc(Number),
  WasmTableImportDesc(WasmTableType),
  WasmMemoryImportDesc(Number, Option<Number>),
  WasmGlobalImportDesc(WasmGlobalType),
}
/**
 * Represents a wasm import.
 */
provide record WasmImport {
  importModName: String,
  importName: String,
  importDesc: WasmImportDesc,
}
/**
 * Represents parsed wasm sections.
 */
provide enum Sections {
  CustomSection(Bytes),
  TypeSection(List<WasmType>),
  ImportSection(List<WasmImport>),
  FunctionSection(List<Number>),
  TableSection(List<WasmTableType>),
  MemorySection(List<(Number, Option<Number>)>),
  GlobalSection(List<(WasmGlobalType, Expression)>),
  ExportSection(List<WasmExportType>),
  StartSection(Number),
  ElementSection(List<WasmElementSegment>),
  DataCountSection(Number),
  CodeSection(List<WasmFunctionType>),
  DataSection(List<WasmDataSegment>),
}
// Helpers
record WasmParserState {
  bytes: Bytes,
  mut currentByte: Int16,
  mut pos: Number,
}
let _END_OF_INPUT = -1S
// Errors
@unsafe
let toHex = (n: Number) => {
  let x = coerceNumberToWasmI32(n)
  NumberUtils.itoa32(x, 16n)
}
let toHexWithZeroPadding = (n: Number, padTo: Number) => {
  // Note that this function is only called in exceptional cases so no effort
  // was made to optimize it.
  let mut result = toHex(n)
  while (String.length(result) < padTo) {
    result = "0" ++ result
  }
  result
}
let formatByteOrEOL = byte => {
  if (byte == _END_OF_INPUT) "End Of Input"
  else "0x" ++
    toHex(Int16.toNumber(byte))
}
let buildUnexpectedWasmToken =
  (
    parserState: WasmParserState,
    expected: Int16,
    found: Int16,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      formatByteOrEOL(expected) ++
      ", found: " ++
      formatByteOrEOL(found)
    )
  )
}
let buildUnexpectedWasmTokenCustom =
  (
    parserState: WasmParserState,
    expected: String,
    found: String,
  ) => {
  Err(
    UnexpectedWasmToken(
      "Unexpected token at position: " ++
      toString(parserState.pos) ++
      ", expected: " ++
      expected ++
      ", found: " ++
      found
    )
  )
}
// Streaming
@unsafe
let _INT8_BYTE_SIZE = 1n
@unsafe
let _FLOAT32_BYTE_SIZE = 4n
@unsafe
let _FLOAT64_BYTE_SIZE = 8n
@unsafe
let _SIZE_OFFSET = 4n
@unsafe
let _VALUE_OFFSET = 8n
let isAtEndOfInput = parserState => {
  parserState.currentByte == _END_OF_INPUT
}
@unsafe
let readByte = (idx: Number, bytes: Bytes) => {
  from WasmI32 use { (+), (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(idx)
  if (offset + _INT8_BYTE_SIZE > size) {
    _END_OF_INPUT
  } else {
    let n = WasmI32.load8U(ptr + offset, _VALUE_OFFSET)
    tagInt16(n)
  }
}
/**
 * Reads the next byte from the parser state.
 *
 * This uses Int16 over Int8 or Uint8 because we want to support -1 for end of input, but we need to support the entire range of Uint8
 */
let nextByteU = parserState => {
  let mut c = parserState.currentByte
  if (c != _END_OF_INPUT) {
    c = readByte(parserState.pos, parserState.bytes)
    parserState.currentByte = c
    parserState.pos += 1
  }
  c
}
@unsafe
let nextF32 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 4
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { (+), (-), (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 4n
  if (offset + _FLOAT32_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let n = WasmF32.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat32(n)): Number)
  }
}
@unsafe
let nextF64 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 8
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { (+), (-), (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 8n
  if (offset + _FLOAT64_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float64
    let n = WasmF64.load(ptr + offset, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Return
    Ok(WasmI32.toGrain(newFloat64(n)): Number)
  }
}
@unsafe
let nextI128 = parserState => {
  // TODO: Verify This Logic
  parserState.pos += 16
  let lastBytePos = parserState.pos - 1
  let bytes = parserState.bytes
  from WasmI32 use { (+), (-), (>) }
  let ptr = WasmI32.fromGrain(bytes)
  let size = WasmI32.load(ptr, _SIZE_OFFSET)
  let offset = coerceNumberToWasmI32(parserState.pos) - 16n
  if (offset + _FLOAT64_BYTE_SIZE > size) {
    Err(UnexpectedEndOfInput)
  } else {
    // Get Our Float32
    let lower = WasmI64.load(ptr + offset, _VALUE_OFFSET)
    let upper = WasmI64.load(ptr + offset + 8n, _VALUE_OFFSET)
    // Set The CurrentByte
    parserState.currentByte = readByte(lastBytePos, parserState.bytes)
    // Build our Number
    let lower = WasmI32.toGrain(newInt64(lower)): Number
    let upper = WasmI32.toGrain(newInt64(upper)): Number
    // TODO: Verify all this logic works
    let n = lower | upper << 64
    // Return
    Ok(n)
  }
}

let getUleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    result = result | (byte & 0x7f) << shift
    nextByteU(parserState)
    if ((0x80 & byte) == 0) break
    shift += 7
  }
  // Return Result
  result
}
let getleb128AndAdvance = (parserState, limit) => {
  // TODO: Optimize this using unsafe
  // TODO: Enforce limit
  let mut result = 0
  let mut shift = 0
  while (true) {
    let byte = Int16.toNumber(parserState.currentByte)
    nextByteU(parserState)
    result = result | (byte & 0x7f) << shift
    shift += 7
    if ((0x80 & byte) == 0) {
      if (shift < 32 && (byte & 0x40) != 0) {
        result = result | -1 << shift
      }
      break
    }
  }
  // Return Result
  result
}
let getStringAndAdvance = parserState => {
  // TODO: Optimize this using unsafe
  // Get String Length
  let stringLen = getUleb128AndAdvance(parserState, 32)
  // Get The String
  let str = Bytes.slice(parserState.pos - 1, stringLen, parserState.bytes)
  let str = Bytes.toString(str)
  parserState.pos += stringLen - 1
  // Return The String
  str
}
let expectByteAndAdvance =
  (
    expectedByte: Int16,
    parserState: WasmParserState,
  ) => {
  let c = parserState.currentByte
  if (c == expectedByte) {
    nextByteU(parserState)
    None
  } else {
    Some(buildUnexpectedWasmToken(parserState, expectedByte, c))
  }
}
let makeParser = bytes => {
  let parserState = {
    bytes,
    currentByte: readByte(0, bytes),
    pos: 1,
  }: WasmParserState
  parserState
}
let saveParser = parserState => (parserState.pos, parserState.currentByte)
let loadParser = (parserState, (pos, currentByte)) => {
  parserState.pos = pos
  parserState.currentByte = currentByte
}
// Parser
/**
 * Wasm Parsing Utils.
 */
provide module Parser {
  /**
   * Parse a wasm binary into unparsed sections.
   *
   * @param rawBytes: The wasm binary to parse
   *
   * @returns The unparsed sections
   */

  provide let parseModule = rawBytes => {
    // Build Our Parser State
    let parserState = makeParser(rawBytes)
    // Check For Magic Number
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x61S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x73S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x6dS, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Check For Version
    match (expectByteAndAdvance(0x01S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    match (expectByteAndAdvance(0x00S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse Sections
    let mut wasmFile = []
    while (!isAtEndOfInput(parserState)) {
      let sectionID = parserState.currentByte
      nextByteU(parserState)
      // Validate SectionID
      let sectionLen = getUleb128AndAdvance(parserState, 32)
      // Collect Data
      let sectionContent = Bytes.slice(
        parserState.pos - 1,
        sectionLen,
        parserState.bytes
      )
      parserState.pos += sectionLen - 1
      nextByteU(parserState)
      // Collect The Bytes Object We Need
      wasmFile = match (sectionID) {
        0S => [RawCustomSection(sectionContent), ...wasmFile],
        1S => [RawTypeSection(sectionContent), ...wasmFile],
        2S => [RawImportSection(sectionContent), ...wasmFile],
        3S => [RawFunctionSection(sectionContent), ...wasmFile],
        4S => [RawTableSection(sectionContent), ...wasmFile],
        5S => [RawMemorySection(sectionContent), ...wasmFile],
        6S => [RawGlobalSection(sectionContent), ...wasmFile],
        7S => [RawExportSection(sectionContent), ...wasmFile],
        8S => [RawStartSection(sectionContent), ...wasmFile],
        9S => [RawElementSection(sectionContent), ...wasmFile],
        10S => [RawCodeSection(sectionContent), ...wasmFile],
        11S => [RawDataSection(sectionContent), ...wasmFile],
        12S => [RawDataCountSection(sectionContent), ...wasmFile],
        _ => {
          return buildUnexpectedWasmTokenCustom(
            parserState,
            "0-12",
            toString(sectionID)
          )
        },
      }
    }
    // Return
    return Ok(List.reverse(wasmFile))
  }
  // Parse Section
  let parseLimits = parserState => {
    let limitType = parserState.currentByte
    nextByteU(parserState)
    let minLimit = getUleb128AndAdvance(parserState, 32)
    let maxLimit = match (limitType) {
      0x00S => None,
      0x01S => Some(getUleb128AndAdvance(parserState, 32)),
      _ => return Err(InvalidWasmLimitType(limitType)),
    }
    return Ok((minLimit, maxLimit))
  }
  let parseWasmKind = parserState => {
    let wasmType = match (parserState.currentByte) {
      0x00S => Ok(WasmFuncRef),
      // Unknown Type
      c => Err(InvalidWasmType(c)),
    }
    nextByteU(parserState)
    wasmType
  }
  let parseWasmType = (parserState, typeFilter=AllType) => {
    let wasmType = match (parserState.currentByte) {
      // NumType
      0x7fS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI32),
      0x7eS when typeFilter == AllType || typeFilter == NumType => Ok(WasmI64),
      0x7dS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF32),
      0x7cS when typeFilter == AllType || typeFilter == NumType => Ok(WasmF64),
      // VecType
      0x7BS when typeFilter == AllType || typeFilter == VecType => Ok(WasmV128),
      // RefType
      0x70S when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmFuncRef),
      0x6fS when typeFilter == AllType || typeFilter == RefType =>
        Ok(WasmExternRef),
      // Unknown Type
      c => Err(InvalidWasmType(c)),
    }
    nextByteU(parserState)
    wasmType
  }
  let parseFunctionType = parserState => {
    // Expect The Function Start Type
    match (expectByteAndAdvance(0x60S, parserState)) {
      Some(err) => return err,
      None => void,
    }
    // Parse The Params
    let paramCount = getUleb128AndAdvance(parserState, 32)
    let mut params = []
    for (let mut i = 0; i < paramCount; i += 1) {
      let paramType = parseWasmType(parserState, typeFilter=NumType)
      match (paramType) {
        Ok(paramType) => {
          params = [paramType, ...params]
        },
        Err(err) => return Err(err),
      }
    }
    // Parse The Result
    let resultCount = getUleb128AndAdvance(parserState, 32)
    let mut results = []
    for (let mut i = 0; i < resultCount; i += 1) {
      let resultType = parseWasmType(parserState, typeFilter=NumType)
      match (resultType) {
        Ok(resultType) => {
          results = [resultType, ...results]
        },
        Err(err) => return Err(err),
      }
    }
    // Return
    return Ok(WasmFuncType(List.reverse(params), List.reverse(results)))
  }
  let parseTableType = parserState => {
    let tableType = match (parseWasmType(parserState, typeFilter=RefType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let (minLimit, maxLimit) = match (parseLimits(parserState)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    return Ok({ wasmType: tableType, minLimit, maxLimit }: WasmTableType)
  }
  let parseGlobalType = parserState => {
    let valType = match (parseWasmType(parserState, typeFilter=NumType)) {
      Ok(t) => t,
      Err(e) => return Err(e),
    }
    let mutable = match (parserState.currentByte) {
      0x00S => false,
      0x01S => true,
      _ => return Err(InvalidWasmGlobal),
    }
    nextByteU(parserState)
    return Ok({ wasmType: valType, isMutable: mutable }: WasmGlobalType)
  }
  let parseWasmImport = parserState => {
    let importModName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importName = getStringAndAdvance(parserState)
    nextByteU(parserState)
    let importDescType = parserState.currentByte
    nextByteU(parserState)
    // Parse The Import Description
    let importDesc = match (importDescType) {
      0x00S => {
        let typeID = getUleb128AndAdvance(parserState, 32)
        WasmFuncImportDesc(typeID)
      },
      0x01S => {
        let tableType = match (parseTableType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmTableImportDesc(tableType)
      },
      0x02S => {
        let (minLimit, maxLimit) = match (parseLimits(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmMemoryImportDesc(minLimit, maxLimit)
      },
      0x03S => {
        let globalType = match (parseGlobalType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        WasmGlobalImportDesc(globalType)
      },
      _ => return Err(InvalidImportDescType(importDescType)),
    }
    // Return The Import
    return Ok({ importModName, importName, importDesc }: WasmImport)
  }
  let parseBlockType = parserState => {
    match (parserState.currentByte) {
      0x40S => {
        nextByteU(parserState)
        return Ok(EmptyType)
      },
      _ => {
        let savePoint = saveParser(parserState)
        let wasmType = match (parseWasmType(parserState, typeFilter=NumType)) {
          Ok(t) => Ok(t),
          Err(e) => {
            loadParser(parserState, savePoint)
            let typeIdx = getleb128AndAdvance(parserState, 33)
            // TODO: I think this requires special logic because its signed and 33 bit so it wont map properly to our type IDX
            Ok(TypeIdx(typeIdx))
          },
        }
        return wasmType
      },
    }
  }
  let parseMemArg = parserState => {
    let align = getUleb128AndAdvance(parserState, 32)
    let offset = getUleb128AndAdvance(parserState, 32)
    return { align, offset }: WasmMemoryArg
  }
  let rec parseInstr = parserState => {
    let c = parserState.currentByte
    nextByteU(parserState)
    return match (c) {
      // Control Expression
      0x00S => Ok(WasmInstr_Unreachable),
      0x01S => Ok(WasmInstr_Nop),
      0x02S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstr_Block(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x03S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        let exprs = parseExpr(parserState, ParentBlock)
        match (exprs) {
          Ok(exprs) => Ok(WasmInstr_Loop(blockType, exprs)),
          Err(err) => return Err(err),
        }
      },
      0x04S => {
        let blockType = match (parseBlockType(parserState)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        // Parse If
        let mut ifSection = []
        let mut hasElse = false
        while (!isAtEndOfInput(parserState)) {
          let instr = parseInstr(parserState)
          match (instr) {
            Ok(instr) => {
              ifSection = [instr, ...ifSection]
              if (instr == WasmInstr_Else) hasElse = true
              if (instr == WasmInstr_Else || instr == WasmInstr_End) break
            },
            Err(err) => return Err(err),
          }
        }
        match (hasElse) {
          true => {
            let elseSection = parseExpr(parserState, ParentBlock)
            match (elseSection) {
              Ok(elseSection) =>
                Ok(WasmInstr_If_Else(blockType, ifSection, elseSection)),
              Err(err) => return Err(err),
            }
          },
          false => Ok(WasmInstr_If(blockType, ifSection)),
        }
      },
      0x0CS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br(labelIdx))
      },
      0x0DS => {
        let labelIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br_If(labelIdx))
      },
      0x0ES => {
        let labelCount = getUleb128AndAdvance(parserState, 32)
        let mut labelIdxs = []
        for (let mut i = 0; i < labelCount; i += 1) {
          let labelIdx = getUleb128AndAdvance(parserState, 32)
          labelIdxs = [labelIdx, ...labelIdxs]
        }
        let defaultLabel = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Br_Table(List.reverse(labelIdxs), defaultLabel))
      },
      0x0FS => Ok(WasmInstr_Return),
      0x10S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Call(funcIdx))
      },
      0x11S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Call_Indirect(typeIdx, tableIdx))
      },
      0x12S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Return_Call(funcIdx))
      },
      0x13S => {
        let typeIdx = getUleb128AndAdvance(parserState, 32)
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Return_Call_Indirect(typeIdx, tableIdx))
      },
      // Reference Instructions
      0xD0S => {
        let refType = match (parseWasmType(parserState, typeFilter=RefType)) {
          Ok(t) => t,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_Ref_Null(refType))
      },
      0xD1S => Ok(WasmInstr_Ref_Is_Null),
      0xD2S => {
        let funcIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Ref_Func(funcIdx))
      },
      // Parametric Instructions
      0x1AS => Ok(WasmInstr_Drop),
      0x1BS => Ok(WasmInstr_Select(None)),
      0x1CS => {
        let typeCount = getUleb128AndAdvance(parserState, 32)
        let mut types = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let wasmType = match (parseWasmType(
            parserState,
            typeFilter=NumType
          )) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          types = [wasmType, ...types]
        }
        Ok(WasmInstr_Select(Some(List.reverse(types))))
      },
      // Variable Instructions
      0x20S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Get(localIdx))
      },
      0x21S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Set(localIdx))
      },
      0x22S => {
        let localIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Local_Tee(localIdx))
      },
      0x23S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Global_Get(globalIdx))
      },
      0x24S => {
        let globalIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Global_Set(globalIdx))
      },
      // Table Instructions
      0x25S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Table_Get(tableIdx))
      },
      0x26S => {
        let tableIdx = getUleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_Table_Set(tableIdx))
      },
      // Memory Instructions
      0x28S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load(memArg))
      },
      0x29S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load(memArg))
      },
      0x2AS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F32_Load(memArg))
      },
      0x2BS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F64_Load(memArg))
      },
      0x2CS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load8_S(memArg))
      },
      0x2DS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load8_U(memArg))
      },
      0x2ES => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load16_S(memArg))
      },
      0x2FS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Load16_U(memArg))
      },
      0x30S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load8_S(memArg))
      },
      0x31S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load8_U(memArg))
      },
      0x32S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load16_S(memArg))
      },
      0x33S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load16_U(memArg))
      },
      0x34S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load32_S(memArg))
      },
      0x35S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Load32_U(memArg))
      },
      0x36S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store(memArg))
      },
      0x37S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store(memArg))
      },
      0x38S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F32_Store(memArg))
      },
      0x39S => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_F64_Store(memArg))
      },
      0x3AS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store8(memArg))
      },
      0x3BS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I32_Store16(memArg))
      },
      0x3CS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store8(memArg))
      },
      0x3DS => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store16(memArg))
      },
      0x3ES => {
        let memArg = parseMemArg(parserState)
        Ok(WasmInstr_I64_Store32(memArg))
      },
      0x3FS => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstr_Memory_Size)
      },
      0x40S => {
        match (parserState.currentByte) {
          0x00S => nextByteU(parserState),
          c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
        }
        Ok(WasmInstr_Memory_Grow)
      },
      // Numeric Instructions
      0x41S => {
        let value = getleb128AndAdvance(parserState, 32)
        Ok(WasmInstr_I32_Const(value))
      },
      0x42S => {
        let value = getleb128AndAdvance(parserState, 64)
        Ok(WasmInstr_I64_Const(value))
      },
      0x43S => {
        let value = match (nextF32(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_F32_Const(value))
      },
      0x44S => {
        let value = match (nextF64(parserState)) {
          Ok(v) => v,
          Err(e) => return Err(e),
        }
        Ok(WasmInstr_F64_Const(value))
      },
      0x45S => Ok(WasmInstr_I32_Eqz),
      0x46S => Ok(WasmInstr_I32_Eq),
      0x47S => Ok(WasmInstr_I32_Ne),
      0x48S => Ok(WasmInstr_I32_Lt_S),
      0x49S => Ok(WasmInstr_I32_Lt_U),
      0x4AS => Ok(WasmInstr_I32_Gt_S),
      0x4BS => Ok(WasmInstr_I32_Gt_U),
      0x4CS => Ok(WasmInstr_I32_Le_S),
      0x4DS => Ok(WasmInstr_I32_Le_U),
      0x4ES => Ok(WasmInstr_I32_Ge_S),
      0x4FS => Ok(WasmInstr_I32_Ge_U),
      0x50S => Ok(WasmInstr_I64_Eqz),
      0x51S => Ok(WasmInstr_I64_Eq),
      0x52S => Ok(WasmInstr_I64_Ne),
      0x53S => Ok(WasmInstr_I64_Lt_S),
      0x54S => Ok(WasmInstr_I64_Lt_U),
      0x55S => Ok(WasmInstr_I64_Gt_S),
      0x56S => Ok(WasmInstr_I64_Gt_U),
      0x57S => Ok(WasmInstr_I64_Le_S),
      0x58S => Ok(WasmInstr_I64_Le_U),
      0x59S => Ok(WasmInstr_I64_Ge_S),
      0x5AS => Ok(WasmInstr_I64_Ge_U),
      0x5BS => Ok(WasmInstr_F32_Eq),
      0x5CS => Ok(WasmInstr_F32_Ne),
      0x5DS => Ok(WasmInstr_F32_Lt),
      0x5ES => Ok(WasmInstr_F32_Gt),
      0x5FS => Ok(WasmInstr_F32_Le),
      0x60S => Ok(WasmInstr_F32_Ge),
      0x61S => Ok(WasmInstr_F64_Eq),
      0x62S => Ok(WasmInstr_F64_Ne),
      0x63S => Ok(WasmInstr_F64_Lt),
      0x64S => Ok(WasmInstr_F64_Gt),
      0x65S => Ok(WasmInstr_F64_Le),
      0x66S => Ok(WasmInstr_F64_Ge),
      0x67S => Ok(WasmInstr_I32_Clz),
      0x68S => Ok(WasmInstr_I32_Ctz),
      0x69S => Ok(WasmInstr_I32_Popcnt),
      0x6AS => Ok(WasmInstr_I32_Add),
      0x6BS => Ok(WasmInstr_I32_Sub),
      0x6CS => Ok(WasmInstr_I32_Mul),
      0x6DS => Ok(WasmInstr_I32_Div_S),
      0x6ES => Ok(WasmInstr_I32_Div_U),
      0x6FS => Ok(WasmInstr_I32_Rem_S),
      0x70S => Ok(WasmInstr_I32_Rem_U),
      0x71S => Ok(WasmInstr_I32_And),
      0x72S => Ok(WasmInstr_I32_Or),
      0x73S => Ok(WasmInstr_I32_Xor),
      0x74S => Ok(WasmInstr_I32_Shl),
      0x75S => Ok(WasmInstr_I32_Shr_S),
      0x76S => Ok(WasmInstr_I32_Shr_U),
      0x77S => Ok(WasmInstr_I32_Rotl),
      0x78S => Ok(WasmInstr_I32_Rotr),
      0x79S => Ok(WasmInstr_I64_Clz),
      0x7AS => Ok(WasmInstr_I64_Ctz),
      0x7BS => Ok(WasmInstr_I64_Popcnt),
      0x7CS => Ok(WasmInstr_I64_Add),
      0x7DS => Ok(WasmInstr_I64_Sub),
      0x7ES => Ok(WasmInstr_I64_Mul),
      0x7FS => Ok(WasmInstr_I64_Div_S),
      0x80S => Ok(WasmInstr_I64_Div_U),
      0x81S => Ok(WasmInstr_I64_Rem_S),
      0x82S => Ok(WasmInstr_I64_Rem_U),
      0x83S => Ok(WasmInstr_I64_And),
      0x84S => Ok(WasmInstr_I64_Or),
      0x85S => Ok(WasmInstr_I64_Xor),
      0x86S => Ok(WasmInstr_I64_Shl),
      0x87S => Ok(WasmInstr_I64_Shr_S),
      0x88S => Ok(WasmInstr_I64_Shr_U),
      0x89S => Ok(WasmInstr_I64_Rotl),
      0x8AS => Ok(WasmInstr_I64_Rotr),
      0x8BS => Ok(WasmInstr_F32_Abs),
      0x8CS => Ok(WasmInstr_F32_Neg),
      0x8DS => Ok(WasmInstr_F32_Ceil),
      0x8ES => Ok(WasmInstr_F32_Floor),
      0x8FS => Ok(WasmInstr_F32_Trunc),
      0x90S => Ok(WasmInstr_F32_Nearest),
      0x91S => Ok(WasmInstr_F32_Sqrt),
      0x92S => Ok(WasmInstr_F32_Add),
      0x93S => Ok(WasmInstr_F32_Sub),
      0x94S => Ok(WasmInstr_F32_Mul),
      0x95S => Ok(WasmInstr_F32_Div),
      0x96S => Ok(WasmInstr_F32_Min),
      0x97S => Ok(WasmInstr_F32_Max),
      0x98S => Ok(WasmInstr_F32_CopySign),
      0x99S => Ok(WasmInstr_F64_Abs),
      0x9AS => Ok(WasmInstr_F64_Neg),
      0x9BS => Ok(WasmInstr_F64_Ceil),
      0x9CS => Ok(WasmInstr_F64_Floor),
      0x9DS => Ok(WasmInstr_F64_Trunc),
      0x9ES => Ok(WasmInstr_F64_Nearest),
      0x9FS => Ok(WasmInstr_F64_Sqrt),
      0xA0S => Ok(WasmInstr_F64_Add),
      0xA1S => Ok(WasmInstr_F64_Sub),
      0xA2S => Ok(WasmInstr_F64_Mul),
      0xA3S => Ok(WasmInstr_F64_Div),
      0xA4S => Ok(WasmInstr_F64_Min),
      0xA5S => Ok(WasmInstr_F64_Max),
      0xA6S => Ok(WasmInstr_F64_CopySign),
      0xA7S => Ok(WasmInstr_I32_Wrap_I64),
      0xA8S => Ok(WasmInstr_I32_Trunc_F32_S),
      0xA9S => Ok(WasmInstr_I32_Trunc_F32_U),
      0xAAS => Ok(WasmInstr_I32_Trunc_F64_S),
      0xABS => Ok(WasmInstr_I32_Trunc_F64_U),
      0xACS => Ok(WasmInstr_I64_Extend_I32_S),
      0xADS => Ok(WasmInstr_I64_Extend_I32_U),
      0xAES => Ok(WasmInstr_I64_Trunc_F32_S),
      0xAFS => Ok(WasmInstr_I64_Trunc_F32_U),
      0xB0S => Ok(WasmInstr_I64_Trunc_F64_S),
      0xB1S => Ok(WasmInstr_I64_Trunc_F64_U),
      0xB2S => Ok(WasmInstr_F32_Convert_I32_S),
      0xB3S => Ok(WasmInstr_F32_Convert_I32_U),
      0xB4S => Ok(WasmInstr_F32_Convert_I64_S),
      0xB5S => Ok(WasmInstr_F32_Convert_I64_U),
      0xB6S => Ok(WasmInstr_F32_Demote_F64),
      0xB7S => Ok(WasmInstr_F64_Convert_I32_S),
      0xB8S => Ok(WasmInstr_F64_Convert_I32_U),
      0xB9S => Ok(WasmInstr_F64_Convert_I64_S),
      0xBAS => Ok(WasmInstr_F64_Convert_I64_U),
      0xBBS => Ok(WasmInstr_F64_Promote_F32),
      0xBCS => Ok(WasmInstr_I32_Reinterpret_F32),
      0xBDS => Ok(WasmInstr_I64_Reinterpret_F64),
      0xBES => Ok(WasmInstr_F32_Reinterpret_I32),
      0xBFS => Ok(WasmInstr_F64_Reinterpret_I64),
      0xC0S => Ok(WasmInstr_I32_Extend8_S),
      0xC1S => Ok(WasmInstr_I32_Extend16_S),
      0xC2S => Ok(WasmInstr_I64_Extend8_S),
      0xC3S => Ok(WasmInstr_I64_Extend16_S),
      0xC4S => Ok(WasmInstr_I64_Extend32_S),
      // Vector Instructions
      0xFDS => {
        let instrIndex = getUleb128AndAdvance(parserState, 32)
        match (instrIndex) {
          // Vector Load Store
          0 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load(memArg))
          },
          1 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_8x8_Load_S(memArg))
          },
          2 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_8x8_Load_U(memArg))
          },
          3 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_16x4_Load_S(memArg))
          },
          4 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_16x4_Load_U(memArg))
          },
          5 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_32x2_Load_S(memArg))
          },
          6 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_32x2_Load_S(memArg))
          },
          7 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_8_Splat(memArg))
          },
          8 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_16_Splat(memArg))
          },
          9 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_32_Splat(memArg))
          },
          10 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Load_64_Splat(memArg))
          },
          92 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_Load_32_Zero(memArg))
          },
          93 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_Load_64_Zero(memArg))
          },
          11 => {
            let memArg = parseMemArg(parserState)
            Ok(WasmInstr_V128_Store(memArg))
          },
          84 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load8_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          85 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load16_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          86 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load32_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          87 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Load64_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          88 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store8_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          89 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store16_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          90 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store32_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          91 => {
            let memArg = parseMemArg(parserState)
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_V128_Store64_Lane(memArg, Int16.toNumber(laneIdx)))
          },
          12 => {
            let n = match (nextI128(parserState)) {
              Ok(n) => n,
              Err(e) => return Err(e),
            }
            Ok(WasmInstr_V128_Const(n))
          },
          13 => {
            let laneIdx1 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx2 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx3 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx4 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx5 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx6 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx7 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx8 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx9 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx10 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx11 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx12 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx13 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx14 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx15 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            let laneIdx16 = Uint8.fromNumber(
              Int16.toNumber(parserState.currentByte)
            )
            nextByteU(parserState)
            Ok(
              WasmInstr_I8x16_Shuffle(
                laneIdx1,
                laneIdx2,
                laneIdx3,
                laneIdx4,
                laneIdx5,
                laneIdx6,
                laneIdx7,
                laneIdx8,
                laneIdx9,
                laneIdx10,
                laneIdx11,
                laneIdx12,
                laneIdx13,
                laneIdx14,
                laneIdx15,
                laneIdx16
              )
            )
          },
          21 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Extract_Lane_S(Int16.toNumber(laneIdx)))
          },
          22 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Extract_Lane_U(Int16.toNumber(laneIdx)))
          },
          23 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I8x16_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          24 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Extract_Lane_S(Int16.toNumber(laneIdx)))
          },
          25 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Extract_Lane_U(Int16.toNumber(laneIdx)))
          },
          26 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I16x8_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          27 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I32x4_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          28 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I32x4_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          29 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I64x2_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          30 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_I64x2_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          31 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F32x4_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          32 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F32x4_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          33 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F64x2_Extract_Lane(Int16.toNumber(laneIdx)))
          },
          34 => {
            let laneIdx = parserState.currentByte
            nextByteU(parserState)
            Ok(WasmInstr_F64x2_Replace_Lane(Int16.toNumber(laneIdx)))
          },
          14 => Ok(WasmInstr_I8x16_Swizzle),
          15 => Ok(WasmInstr_I8x16_Splat),
          16 => Ok(WasmInstr_I16x8_Splat),
          17 => Ok(WasmInstr_I32x4_Splat),
          18 => Ok(WasmInstr_I64x2_Splat),
          19 => Ok(WasmInstr_F32x4_Splat),
          20 => Ok(WasmInstr_F64x2_Splat),
          35 => Ok(WasmInstr_I8x16_Eq),
          36 => Ok(WasmInstr_I8x16_Ne),
          37 => Ok(WasmInstr_I8x16_Lt_S),
          38 => Ok(WasmInstr_I8x16_Lt_U),
          39 => Ok(WasmInstr_I8x16_Gt_S),
          40 => Ok(WasmInstr_I8x16_Gt_U),
          41 => Ok(WasmInstr_I8x16_Le_S),
          42 => Ok(WasmInstr_I8x16_Le_U),
          43 => Ok(WasmInstr_I8x16_Ge_S),
          44 => Ok(WasmInstr_I8x16_Ge_U),
          45 => Ok(WasmInstr_I16x8_Eq),
          46 => Ok(WasmInstr_I16x8_Ne),
          47 => Ok(WasmInstr_I16x8_Lt_S),
          48 => Ok(WasmInstr_I16x8_Lt_U),
          49 => Ok(WasmInstr_I16x8_Gt_S),
          50 => Ok(WasmInstr_I16x8_Gt_U),
          51 => Ok(WasmInstr_I16x8_Le_S),
          52 => Ok(WasmInstr_I16x8_Le_U),
          53 => Ok(WasmInstr_I16x8_Ge_S),
          54 => Ok(WasmInstr_I16x8_Ge_U),
          55 => Ok(WasmInstr_I32x4_Eq),
          56 => Ok(WasmInstr_I32x4_Ne),
          57 => Ok(WasmInstr_I32x4_Lt_S),
          58 => Ok(WasmInstr_I32x4_Lt_U),
          59 => Ok(WasmInstr_I32x4_Gt_S),
          60 => Ok(WasmInstr_I32x4_Gt_U),
          61 => Ok(WasmInstr_I32x4_Le_S),
          62 => Ok(WasmInstr_I32x4_Le_U),
          63 => Ok(WasmInstr_I32x4_Ge_S),
          64 => Ok(WasmInstr_I32x4_Ge_U),
          214 => Ok(WasmInstr_I64x2_Eq),
          215 => Ok(WasmInstr_I64x2_Ne),
          216 => Ok(WasmInstr_I64x2_Lt_S),
          217 => Ok(WasmInstr_I64x2_Gt_S),
          218 => Ok(WasmInstr_I64x2_Le_S),
          219 => Ok(WasmInstr_I64x2_Ge_S),
          65 => Ok(WasmInstr_F32x4_Eq),
          66 => Ok(WasmInstr_F32x4_Ne),
          67 => Ok(WasmInstr_F32x4_Lt),
          68 => Ok(WasmInstr_F32x4_Gt),
          69 => Ok(WasmInstr_F32x4_Le),
          70 => Ok(WasmInstr_F32x4_Ge),
          71 => Ok(WasmInstr_F64x2_Eq),
          72 => Ok(WasmInstr_F64x2_Ne),
          73 => Ok(WasmInstr_F64x2_Lt),
          74 => Ok(WasmInstr_F64x2_Gt),
          75 => Ok(WasmInstr_F64x2_Le),
          76 => Ok(WasmInstr_F64x2_Ge),
          77 => Ok(WasmInstr_V128_Not),
          78 => Ok(WasmInstr_V128_And),
          79 => Ok(WasmInstr_V128_And_Not),
          80 => Ok(WasmInstr_V128_Or),
          81 => Ok(WasmInstr_V128_Xor),
          82 => Ok(WasmInstr_V128_Bitselect),
          83 => Ok(WasmInstr_V128_Any_True),
          96 => Ok(WasmInstr_I8x16_Abs),
          97 => Ok(WasmInstr_I8x16_Neg),
          98 => Ok(WasmInstr_I8x16_Popcnt),
          99 => Ok(WasmInstr_I8x16_All_True),
          100 => Ok(WasmInstr_I8x16_Bitmask),
          101 => Ok(WasmInstr_I8x16_Narrow_I16x8_S),
          102 => Ok(WasmInstr_I8x16_Narrow_I16x8_U),
          107 => Ok(WasmInstr_I8x16_Shl),
          108 => Ok(WasmInstr_I8x16_Shr_S),
          109 => Ok(WasmInstr_I8x16_Shr_U),
          110 => Ok(WasmInstr_I8x16_Add),
          111 => Ok(WasmInstr_I8x16_Add_Sat_S),
          112 => Ok(WasmInstr_I8x16_Add_Sat_U),
          113 => Ok(WasmInstr_I8x16_Sub),
          114 => Ok(WasmInstr_I8x16_Sub_Sat_S),
          115 => Ok(WasmInstr_I8x16_Sub_Sat_U),
          118 => Ok(WasmInstr_I8x16_Min_S),
          119 => Ok(WasmInstr_I8x16_Min_U),
          120 => Ok(WasmInstr_I8x16_Max_S),
          121 => Ok(WasmInstr_I8x16_Max_U),
          123 => Ok(WasmInstr_I8x16_Avgr_U),
          124 => Ok(WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_S),
          125 => Ok(WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_U),
          128 => Ok(WasmInstr_I16x8_Abs),
          129 => Ok(WasmInstr_I16x8_Neg),
          130 => Ok(WasmInstr_I16x8_q15mulr_sat_s),
          131 => Ok(WasmInstr_I16x8_All_True),
          132 => Ok(WasmInstr_I16x8_Bitmask),
          133 => Ok(WasmInstr_I16x8_Narrow_I32x4_S),
          134 => Ok(WasmInstr_I16x8_Narrow_I32x4_U),
          135 => Ok(WasmInstr_I16x8_Extend_Low_I8x16_S),
          136 => Ok(WasmInstr_I16x8_Extend_High_I8x16_S),
          137 => Ok(WasmInstr_I16x8_Extend_Low_I8x16_U),
          138 => Ok(WasmInstr_I16x8_Extend_High_I8x16_U),
          139 => Ok(WasmInstr_I16x8_Shl),
          140 => Ok(WasmInstr_I16x8_Shr_S),
          141 => Ok(WasmInstr_I16x8_Shr_U),
          142 => Ok(WasmInstr_I16x8_Add),
          143 => Ok(WasmInstr_I16x8_Add_Sat_S),
          144 => Ok(WasmInstr_I16x8_Add_Sat_U),
          145 => Ok(WasmInstr_I16x8_Sub),
          146 => Ok(WasmInstr_I16x8_Sub_Sat_S),
          147 => Ok(WasmInstr_I16x8_Sub_Sat_U),
          149 => Ok(WasmInstr_I16x8_Mul),
          150 => Ok(WasmInstr_I16x8_Min_S),
          151 => Ok(WasmInstr_I16x8_Min_U),
          152 => Ok(WasmInstr_I16x8_Max_S),
          153 => Ok(WasmInstr_I16x8_Max_U),
          155 => Ok(WasmInstr_I16x8_Avgr_U),
          156 => Ok(WasmInstr_I16x8_ExtMulLow_I8x16_S),
          157 => Ok(WasmInstr_I16x8_ExtMulHigh_I8x16_S),
          158 => Ok(WasmInstr_I16x8_ExtMulLow_I8x16_U),
          159 => Ok(WasmInstr_I16x8_ExtMulHigh_I8x16_U),
          126 => Ok(WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_S),
          127 => Ok(WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_U),
          160 => Ok(WasmInstr_I32x4_Abs),
          161 => Ok(WasmInstr_I32x4_Neg),
          163 => Ok(WasmInstr_I32x4_All_True),
          164 => Ok(WasmInstr_I32x4_Bitmask),
          167 => Ok(WasmInstr_I32x4_Extend_Low_I16x8_S),
          168 => Ok(WasmInstr_I32x4_Extend_High_I16x8_S),
          169 => Ok(WasmInstr_I32x4_Extend_Low_I16x8_U),
          170 => Ok(WasmInstr_I32x4_Extend_High_I16x8_U),
          171 => Ok(WasmInstr_I32x4_Shl),
          172 => Ok(WasmInstr_I32x4_Shr_S),
          173 => Ok(WasmInstr_I32x4_Shr_U),
          174 => Ok(WasmInstr_I32x4_Add),
          177 => Ok(WasmInstr_I32x4_Sub),
          181 => Ok(WasmInstr_I32x4_Mul),
          182 => Ok(WasmInstr_I32x4_Min_S),
          183 => Ok(WasmInstr_I32x4_Min_U),
          184 => Ok(WasmInstr_I32x4_Max_S),
          185 => Ok(WasmInstr_I32x4_Max_U),
          186 => Ok(WasmInstr_I32x4_Dot_I16x8_S),
          188 => Ok(WasmInstr_I32x4_ExtMulLow_I16x8_S),
          189 => Ok(WasmInstr_I32x4_ExtMulHigh_I16x8_S),
          190 => Ok(WasmInstr_I32x4_ExtMulLow_I16x8_U),
          191 => Ok(WasmInstr_I32x4_ExtMulHigh_I16x8_U),
          192 => Ok(WasmInstr_I64x2_Abs),
          193 => Ok(WasmInstr_I64x2_Neg),
          195 => Ok(WasmInstr_I64x2_All_True),
          196 => Ok(WasmInstr_I64x2_Bitmask),
          199 => Ok(WasmInstr_I64x2_Extend_Low_I32x4_S),
          200 => Ok(WasmInstr_I64x2_Extend_High_I32x4_S),
          201 => Ok(WasmInstr_I64x2_Extend_Low_I32x4_U),
          202 => Ok(WasmInstr_I64x2_Extend_High_I32x4_U),
          203 => Ok(WasmInstr_I64x2_Shl),
          204 => Ok(WasmInstr_I64x2_Shr_S),
          205 => Ok(WasmInstr_I64x2_Shr_U),
          206 => Ok(WasmInstr_I64x2_Add),
          209 => Ok(WasmInstr_I64x2_Sub),
          213 => Ok(WasmInstr_I64x2_Mul),
          220 => Ok(WasmInstr_I64x2_ExtMulLow_I32x4_S),
          221 => Ok(WasmInstr_I64x2_ExtMulHigh_I32x4_S),
          222 => Ok(WasmInstr_I64x2_ExtMulLow_I32x4_U),
          223 => Ok(WasmInstr_I64x2_ExtMulHigh_I32x4_U),
          103 => Ok(WasmInstr_F32x4_Ceil),
          104 => Ok(WasmInstr_F32x4_Floor),
          105 => Ok(WasmInstr_F32x4_Trunc),
          106 => Ok(WasmInstr_F32x4_Nearest),
          224 => Ok(WasmInstr_F32x4_Abs),
          225 => Ok(WasmInstr_F32x4_Neg),
          227 => Ok(WasmInstr_F32x4_Sqrt),
          228 => Ok(WasmInstr_F32x4_Add),
          229 => Ok(WasmInstr_F32x4_Sub),
          230 => Ok(WasmInstr_F32x4_Mul),
          231 => Ok(WasmInstr_F32x4_Div),
          232 => Ok(WasmInstr_F32x4_Min),
          233 => Ok(WasmInstr_F32x4_Max),
          234 => Ok(WasmInstr_F32x4_Pmin),
          235 => Ok(WasmInstr_F32x4_Pmax),
          116 => Ok(WasmInstr_F64x2_Ceil),
          117 => Ok(WasmInstr_F64x2_Floor),
          122 => Ok(WasmInstr_F64x2_Trunc),
          148 => Ok(WasmInstr_F64x2_Nearest),
          236 => Ok(WasmInstr_F64x2_Abs),
          237 => Ok(WasmInstr_F64x2_Neg),
          239 => Ok(WasmInstr_F64x2_Sqrt),
          240 => Ok(WasmInstr_F64x2_Add),
          241 => Ok(WasmInstr_F64x2_Sub),
          242 => Ok(WasmInstr_F64x2_Mul),
          243 => Ok(WasmInstr_F64x2_Div),
          244 => Ok(WasmInstr_F64x2_Min),
          245 => Ok(WasmInstr_F64x2_Max),
          246 => Ok(WasmInstr_F64x2_Pmin),
          247 => Ok(WasmInstr_F64x2_Pmax),
          248 => Ok(WasmInstr_I32x4_Trunc_Sat_F32x4_S),
          249 => Ok(WasmInstr_I32x4_Trunc_Sat_F32x4_U),
          250 => Ok(WasmInstr_F32x4_Convert_I32x4_S),
          251 => Ok(WasmInstr_F32x4_Convert_I32x4_U),
          252 => Ok(WasmInstr_I32x4_Trunc_Sat_F64x2_S_Zero),
          253 => Ok(WasmInstr_I32x4_Trunc_Sat_F64x2_U_Zero),
          254 => Ok(WasmInstr_F64x2_ConvertLow_I32x4_S),
          255 => Ok(WasmInstr_F64x2_ConvertLow_I32x4_U),
          94 => Ok(WasmInstr_F32x4_Demote_F64x2_Zero),
          095 => Ok(WasmInstr_F64x2_PromoteLow_F32x4),
          // Invalid
          _ =>
            buildUnexpectedWasmTokenCustom(
              parserState,
              "0-255",
              toString(instrIndex)
            ),
        }
      },
      // 0xFC leading
      0xFCS => {
        let instrIndex = getUleb128AndAdvance(parserState, 32)
        match (instrIndex) {
          // Table Instructions
          12 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Init(elemIndex, tableIndex))
          },
          13 => {
            let elemIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Elem_Drop(elemIndex))
          },
          14 => {
            let tableIndex1 = getUleb128AndAdvance(parserState, 32)
            let tableIndex2 = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Copy(tableIndex1, tableIndex2))
          },
          15 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Grow(tableIndex))
          },
          16 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Size(tableIndex))
          },
          17 => {
            let tableIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Table_Fill(tableIndex))
          },
          // Memory Instructions
          8 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Init(dataIndex))
          },
          9 => {
            let dataIndex = getUleb128AndAdvance(parserState, 32)
            Ok(WasmInstr_Data_Drop(dataIndex))
          },
          10 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Copy)
          },
          11 => {
            match (parserState.currentByte) {
              0x00S => nextByteU(parserState),
              c => return buildUnexpectedWasmToken(parserState, 0x00S, c),
            }
            Ok(WasmInstr_Memory_Fill)
          },
          // Numeric Instructions
          0 => Ok(WasmInstr_I32_TruncSat_F32_S),
          1 => Ok(WasmInstr_I32_TruncSat_F32_U),
          2 => Ok(WasmInstr_I32_TruncSat_F64_S),
          3 => Ok(WasmInstr_I32_TruncSat_F64_U),
          4 => Ok(WasmInstr_I64_TruncSat_F32_S),
          5 => Ok(WasmInstr_I64_TruncSat_F32_U),
          6 => Ok(WasmInstr_I64_TruncSat_F64_S),
          7 => Ok(WasmInstr_I64_TruncSat_F64_U),
          // Invalid
          _ =>
            buildUnexpectedWasmTokenCustom(
              parserState,
              "0-17",
              toString(instrIndex)
            ),
        }
      },
      // End Instruction
      // TODO: Realistically you should never be able to get an else instr we need to get rid of this instruction code
      0x05S => Ok(WasmInstr_Else),
      0x0BS => Ok(WasmInstr_End),
      // Invalid
      c => Err(InvalidWasmInstr(c)),
    }
  }
  and parseExpr = (parserState, parent) => {
    let mut exprs = []
    while (!isAtEndOfInput(parserState)) {
      let instr = parseInstr(parserState)
      match (instr) {
        Ok(instr) => {
          exprs = [instr, ...exprs]
          if (instr == WasmInstr_End) break
        },
        Err(err) => return Err(err),
      }
    }
    return Ok(List.reverse(exprs))
  }

  /**
   * Parse a section into a parsed wasm section.
   *
   * @param section: The unparsed section to parse
   *
   * @returns The parsed section
   */

  provide let parseSection = section => {
    // Match The Section
    let section = match (section) {
      RawCustomSection(bytes) => CustomSection(bytes),
      RawTypeSection(bytes) => {
        let parserState = makeParser(bytes)
        // This Contains Function Types
        let typeCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Function Types
        let mut functionTypes = []
        for (let mut i = 0; i < typeCount; i += 1) {
          let functionType = parseFunctionType(parserState)
          match (functionType) {
            Ok(functionType) => {
              functionTypes = [functionType, ...functionTypes]
              void
            },
            Err(err) => return Err(err),
          }
        }
        TypeSection(List.reverse(functionTypes))
      },
      RawImportSection(bytes) => {
        let parserState = makeParser(bytes)
        let importCount = getUleb128AndAdvance(parserState, 32)
        // Parse The Import Types
        let mut wasmImports = []
        for (let mut i = 0; i < importCount; i += 1) {
          let wasmImport = parseWasmImport(parserState)
          match (wasmImport) {
            Ok(wasmImport) => {
              wasmImports = [wasmImport, ...wasmImports]
              void
            },
            Err(err) => return Err(err),
          }
        }
        ImportSection(List.reverse(wasmImports))
      },
      RawFunctionSection(bytes) => {
        let parserState = makeParser(bytes)
        let funcCount = getUleb128AndAdvance(parserState, 32)
        let mut funcTypes = []
        for (let mut i = 0; i < funcCount; i += 1) {
          let funcType = getUleb128AndAdvance(parserState, 32)
          funcTypes = [funcType, ...funcTypes]
        }
        FunctionSection(List.reverse(funcTypes))
      },
      RawTableSection(bytes) => {
        let parserState = makeParser(bytes)
        let tableCount = getUleb128AndAdvance(parserState, 32)
        let mut tableTypes = []
        for (let mut i = 0; i < tableCount; i += 1) {
          let tableType = match (parseTableType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          tableTypes = [tableType, ...tableTypes]
        }
        TableSection(List.reverse(tableTypes))
      },
      RawMemorySection(bytes) => {
        let parserState = makeParser(bytes)
        let memCount = getUleb128AndAdvance(parserState, 32)
        let mut memTypes = []
        for (let mut i = 0; i < memCount; i += 1) {
          let (minLimit, maxLimit) = match (parseLimits(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          memTypes = [(minLimit, maxLimit), ...memTypes]
        }
        MemorySection(List.reverse(memTypes))
      },
      RawGlobalSection(bytes) => {
        let parserState = makeParser(bytes)
        let globalCount = getUleb128AndAdvance(parserState, 32)
        let mut globalTypes = []
        for (let mut i = 0; i < globalCount; i += 1) {
          let globalType = match (parseGlobalType(parserState)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          let globalValue = match (parseExpr(parserState, ParentGlobal)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          globalTypes = [(globalType, globalValue), ...globalTypes]
        }
        GlobalSection(List.reverse(globalTypes))
      },
      RawExportSection(bytes) => {
        let parserState = makeParser(bytes)
        let exportCount = getUleb128AndAdvance(parserState, 32)
        let mut exports = []
        for (let mut i = 0; i < exportCount; i += 1) {
          // Parse Export Name
          let name = getStringAndAdvance(parserState)
          nextByteU(parserState)
          // Parse Export Description
          let exportDescType = parserState.currentByte
          nextByteU(parserState)
          let idx = getUleb128AndAdvance(parserState, 32)
          let exportDesc = match (exportDescType) {
            0x00S => FuncExport(idx),
            0x01S => TableExport(idx),
            0x02S => MemoryExport(idx),
            0x03S => GlobalExport(idx),
            c => return Err(InvalidExportDescription(c)),
          }
          exports = [{ name, exportDesc }: WasmExportType, ...exports]
        }
        ExportSection(List.reverse(exports))
      },
      RawStartSection(bytes) => {
        let parserState = makeParser(bytes)
        let startIdx = getUleb128AndAdvance(parserState, 32)
        StartSection(startIdx)
      },
      RawElementSection(bytes) => {
        let parserState = makeParser(bytes)
        let elementCount = getUleb128AndAdvance(parserState, 32)
        let mut elements = []
        for (let mut i = 0; i < elementCount; i += 1) {
          let elementType = getUleb128AndAdvance(parserState, 32)
          match (elementType) {
            0 => {
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: WasmFuncRef,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemActive{ tableIdx: 0, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            1 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemPassive,
                }: WasmElementSegment,
                ...elements
              ]
            },
            2 => {
              let tableIndex = getUleb128AndAdvance(parserState, 32)
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemActive{ tableIdx: tableIndex, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            3 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let funcCount = getUleb128AndAdvance(parserState, 32)
              let mut funcIndices = []
              for (let mut i = 0; i < funcCount; i += 1) {
                let funcIdx = getUleb128AndAdvance(parserState, 32)
                funcIndices = [WasmInstr_Ref_Func(funcIdx), ...funcIndices]
              }
              funcIndices = [WasmInstr_End, ...funcIndices]
              elements = [
                {
                  wasmType: elemKind,
                  contents: [List.reverse(funcIndices)],
                  elemMode: ElemDeclarative,
                }: WasmElementSegment,
                ...elements
              ]
            },
            4 => {
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: WasmFuncRef,
                  contents: List.reverse(exprs),
                  elemMode: ElemActive{ tableIdx: 0, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            5 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemPassive,
                }: WasmElementSegment,
                ...elements
              ]
            },
            6 => {
              let tableIndex = getUleb128AndAdvance(parserState, 32)
              let expr = match (parseExpr(parserState, ParentElement)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemActive{ tableIdx: tableIndex, offset: expr },
                }: WasmElementSegment,
                ...elements
              ]
            },
            7 => {
              let elemKind = match (parseWasmKind(parserState)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              let exprCount = getUleb128AndAdvance(parserState, 32)
              let mut exprs = []
              for (let mut i = 0; i < exprCount; i += 1) {
                let expr = match (parseExpr(parserState, ParentElement)) {
                  Ok(t) => t,
                  Err(e) => return Err(e),
                }
                exprs = [expr, ...exprs]
              }
              elements = [
                {
                  wasmType: elemKind,
                  contents: List.reverse(exprs),
                  elemMode: ElemDeclarative,
                }: WasmElementSegment,
                ...elements
              ]
            },
            _ =>
              return buildUnexpectedWasmTokenCustom(
                parserState,
                "0-7",
                toString(elementType)
              ),
          }
        }
        ElementSection(List.reverse(elements))
      },
      RawDataCountSection(bytes) => {
        let parserState = makeParser(bytes)
        let dataCount = getUleb128AndAdvance(parserState, 32)
        DataCountSection(dataCount)
      },
      RawCodeSection(bytes) => {
        let parserState = makeParser(bytes)
        let codeCount = getUleb128AndAdvance(parserState, 32)
        let mut functions = []
        for (let mut i = 0; i < codeCount; i += 1) {
          // Get Function Size
          let funcSize = getUleb128AndAdvance(parserState, 32)
          // Get Function Locals
          let localCount = getUleb128AndAdvance(parserState, 32)
          let mut locals = []
          for (let mut j = 0; j < localCount; j += 1) {
            let localTypeCount = getUleb128AndAdvance(parserState, 32)
            let localType = match (parseWasmType(parserState)) {
              Ok(t) => t,
              Err(e) => return Err(e),
            }
            locals = [
              { wasmType: localType, count: localTypeCount }: WasmLocalType,
              ...locals
            ]
          }
          // Parse The Function Body
          let wasmBody = match (parseExpr(parserState, ParentFunction)) {
            Ok(t) => t,
            Err(e) => return Err(e),
          }
          // Add To List
          functions = [
            { locals: List.reverse(locals), body: wasmBody }: WasmFunctionType,
            ...functions
          ]
        }
        CodeSection(List.reverse(functions))
      },
      RawDataSection(bytes) => {
        let parserState = makeParser(bytes)
        let dataCount = getUleb128AndAdvance(parserState, 32)
        let mut data = []
        for (let mut i = 0; i < dataCount; i += 1) {
          // Parse Each Section
          let dataLayout = getUleb128AndAdvance(parserState, 32)
          match (dataLayout) {
            0 => {
              let expr = match (parseExpr(parserState, ParentData)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataActive{ memIdx: 0, offset: expr, content }, ...data]
            },
            1 => {
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataPassive{ content, }, ...data]
            },
            2 => {
              // Get Memory Index
              let memIdx = getUleb128AndAdvance(parserState, 32)
              // Get Offset
              let expr = match (parseExpr(parserState, ParentData)) {
                Ok(t) => t,
                Err(e) => return Err(e),
              }
              // WasmDataSection
              let size = getUleb128AndAdvance(parserState, 32)
              // Get Bytes
              if (
                parserState.pos - 1 + size > Bytes.length(parserState.bytes)
              ) {
                return Err(UnexpectedEndOfInput)
              }
              let content = Bytes.slice(
                parserState.pos - 1,
                size,
                parserState.bytes
              )
              parserState.pos += size - 1
              nextByteU(parserState)
              // Add To List
              data = [DataActive{ memIdx, offset: expr, content }, ...data]
            },
            _ =>
              return buildUnexpectedWasmTokenCustom(
                parserState,
                "0-2",
                toString(dataLayout)
              ),
          }
        }
        DataSection(List.reverse(data))
      },
    }
    // Return
    return Ok(section)
  }
}
// Builder
/**
 * Wasm Building Utils.
 */
provide module Builder {
  // Types
  /**
   * Represents errors for Wasm building.
   */

  provide enum WasmBuildError {
    InvalidTypeInFunction,
    InvalidTypeInTypeSection,
    InvalidTableTypeImport,
    InvalidGlobalDescription,
    InvalidWasmBlockType,
    InvalidReferenceType,
    InvalidValueType,
  }
  // Helpers
  let bufAddUleb128 = (value: Number, buf: Buffer.Buffer) => {
    let mut value = value
    while (true) {
      let mut byte = value & 0x7f
      value = value >>> 7
      if (value != 0) {
        byte = byte | 0x80
      }
      Buffer.addUint8(Uint8.fromNumber(byte), buf)
      if (value == 0) break
    }
  }
  let bufAddLeb128 = (value: Number, buf: Buffer.Buffer) => {
    // TODO: Verify this is correct
    let mut value = value
    value = value | 0
    while (true) {
      let byte_ = value & 0x7f
      value = value >> 7
      if (
        value == 0 && (byte_ & 0x40) == 0 || value == -1 && (byte_ & 0x40) != 0
      ) {
        Buffer.addUint8(Uint8.fromNumber(byte_), buf)
        break
      }
      Buffer.addUint8(Uint8.fromNumber(byte_ | 0x80), buf)
    }
  }
  let buffAddStr = (value: String, buf: Buffer.Buffer) => {
    // Add String Length
    bufAddUleb128(String.length(value), buf)
    // Add String Contents
    Buffer.addString(value, buf)
  }
  // Bundle The Raw Sections
  let buildMemArg = (value: WasmMemoryArg, buf: Buffer.Buffer) => {
    bufAddUleb128(value.align, buf)
    bufAddUleb128(value.offset, buf)
  }
  let buildBlockType = (blockType: WasmType, buf: Buffer.Buffer) => {
    // TODO: Roll this into the compile type
    match (blockType) {
      EmptyType => Buffer.addUint8(0x40us, buf),
      WasmI32 => Buffer.addUint8(0x7Fus, buf),
      WasmI64 => Buffer.addUint8(0x7Eus, buf),
      WasmF32 => Buffer.addUint8(0x7Dus, buf),
      WasmF64 => Buffer.addUint8(0x7Cus, buf),
      // TODO: We need to encode this specially
      TypeIdx(typeIdx) => bufAddLeb128(typeIdx, buf),
      _ => return Some(InvalidWasmBlockType),
    }
    return None
  }
  let buildLimit = (min: Number, max: Option<Number>, buf: Buffer.Buffer) => {
    match (max) {
      None => {
        Buffer.addUint8(0x00us, buf)
        bufAddUleb128(min, buf)
      },
      Some(max) => {
        Buffer.addUint8(0x01us, buf)
        bufAddUleb128(min, buf)
        bufAddUleb128(max, buf)
      },
    }
  }
  let buildWasmGlobal = (wasmGlobal: WasmGlobalType, buf: Buffer.Buffer) => {
    // Compile Type
    match (wasmGlobal.wasmType) {
      // TODO: Break this into a compile WasmType
      WasmI32 => Buffer.addUint8(0x7Fus, buf),
      WasmI64 => Buffer.addUint8(0x7Eus, buf),
      WasmF32 => Buffer.addUint8(0x7Dus, buf),
      WasmF64 => Buffer.addUint8(0x7Cus, buf),
      // Invalid Types
      _ => return Some(InvalidGlobalDescription),
    }
    // Compile Mut Flag
    match (wasmGlobal.isMutable) {
      true => Buffer.addUint8(0x01us, buf),
      false => Buffer.addUint8(0x00us, buf),
    }
    return None
  }
  let buildRawSection =
    (
      sectionID: Uint8,
      bytes: Bytes,
      buffer: Buffer.Buffer,
    ) => {
    // Add the section ID
    Buffer.addUint8(sectionID, buffer)
    // Add The Section Size
    bufAddUleb128(Bytes.length(bytes), buffer)
    // Add The Buffer
    Buffer.addBytes(bytes, buffer)
  }
  // Build Expr
  let rec buildInstr = (instr, buf) => {
    // TODO: Refactor this to take advantage of tail calls
    match (instr) {
      // Control Instructions
      WasmInstr_Unreachable => Buffer.addUint8(0x00us, buf),
      WasmInstr_Nop => Buffer.addUint8(0x01us, buf),
      WasmInstr_Block(blockType, expr) => {
        Buffer.addUint8(0x02us, buf)
        // Compile Block Type
        match (buildBlockType(blockType, buf)) {
          Some(err) => return Some(err),
          None => void,
        }
        // Compile Block
        return buildExpr(expr, buf)
      },
      WasmInstr_Loop(blockType, expr) => {
        Buffer.addUint8(0x03us, buf)
        // Compile Block Type
        match (buildBlockType(blockType, buf)) {
          Some(err) => return Some(err),
          None => void,
        }
        // Compile Block
        return buildExpr(expr, buf)
      },
      WasmInstr_If(blockType, expr) => {
        Buffer.addUint8(0x04us, buf)
        // Compile Block Type
        match (buildBlockType(blockType, buf)) {
          Some(err) => return Some(err),
          None => void,
        }
        // Compile Block
        return buildExpr(expr, buf)
      },
      WasmInstr_If_Else(blockType, exprTrue, exprFalse) => {
        Buffer.addUint8(0x02us, buf)
        // Compile Block Type
        match (buildBlockType(blockType, buf)) {
          Some(err) => return Some(err),
          None => void,
        }
        // Compile Block
        match (buildExpr(exprTrue, buf)) {
          Some(err) => return Some(err),
          None => void,
        }
        Buffer.addUint8(0x05us, buf)
        return buildExpr(exprFalse, buf)
      },
      WasmInstr_Br(labelIdx) => {
        Buffer.addUint8(0x0Cus, buf)
        bufAddUleb128(labelIdx, buf)
      },
      WasmInstr_Br_If(labelIdx) => {
        Buffer.addUint8(0x0Dus, buf)
        bufAddUleb128(labelIdx, buf)
      },
      WasmInstr_Br_Table(labels, labelIdx) => {
        Buffer.addUint8(0x0Cus, buf)
        bufAddUleb128(List.length(labels), buf)
        List.forEach(label => {
          bufAddUleb128(label, buf)
        }, labels)
        bufAddUleb128(labelIdx, buf)
      },
      WasmInstr_Return => Buffer.addUint8(0x0Fus, buf),
      WasmInstr_Call(funcIdx) => {
        Buffer.addUint8(0x10us, buf)
        bufAddUleb128(funcIdx, buf)
      },
      WasmInstr_Call_Indirect(typeIdx, tableIdx) => {
        Buffer.addUint8(0x11us, buf)
        bufAddUleb128(typeIdx, buf)
        bufAddUleb128(tableIdx, buf)
      },
      WasmInstr_Return_Call(typeIdx) => {
        Buffer.addUint8(0x12us, buf)
        bufAddUleb128(typeIdx, buf)
      },
      WasmInstr_Return_Call_Indirect(typeIdx, tableIdx) => {
        Buffer.addUint8(0x13us, buf)
        bufAddUleb128(typeIdx, buf)
        bufAddUleb128(tableIdx, buf)
      },
      // Reference Instructions
      WasmInstr_Ref_Null(wasmType) => {
        Buffer.addUint8(0xD0us, buf)
        // TODO: Move this to a compile type
        match (wasmType) {
          WasmFuncRef => Buffer.addUint8(0x00us, buf),
          WasmExternRef => Buffer.addUint8(0x01us, buf),
          _ => return Some(InvalidReferenceType),
        }
      },
      WasmInstr_Ref_Is_Null => Buffer.addUint8(0xD1us, buf),
      WasmInstr_Ref_Func(funcIdx) => {
        Buffer.addUint8(0xD2us, buf)
        bufAddUleb128(funcIdx, buf)
      },
      // Parametric Instructions
      WasmInstr_Drop => Buffer.addUint8(0x1Aus, buf),
      WasmInstr_Select(valTypes) => {
        match (valTypes) {
          None => Buffer.addUint8(0x1Bus, buf),
          Some(valTypes) => {
            Buffer.addUint8(0x1Cus, buf)
            bufAddUleb128(List.length(valTypes), buf)
            let mut err = None
            List.forEach(valType => {
              if (err == None) {
                match (valType) {
                  WasmI32 => Buffer.addUint8(0x7Fus, buf),
                  WasmI64 => Buffer.addUint8(0x7Eus, buf),
                  WasmF32 => Buffer.addUint8(0x7Dus, buf),
                  WasmF64 => Buffer.addUint8(0x7Cus, buf),
                  _ => err = Some(InvalidValueType),
                }
              }
            }, valTypes)
            if (err != None) return err
          },
        }
      },
      // Variable Instructions
      WasmInstr_Local_Get(localIdx) => {
        Buffer.addUint8(0x20us, buf)
        bufAddUleb128(localIdx, buf)
      },
      WasmInstr_Local_Set(localIdx) => {
        Buffer.addUint8(0x21us, buf)
        bufAddUleb128(localIdx, buf)
      },
      WasmInstr_Local_Tee(localIdx) => {
        Buffer.addUint8(0x22us, buf)
        bufAddUleb128(localIdx, buf)
      },
      WasmInstr_Global_Get(globalIdx) => {
        Buffer.addUint8(0x23us, buf)
        bufAddUleb128(globalIdx, buf)
      },
      WasmInstr_Global_Set(globalIdx) => {
        Buffer.addUint8(0x24us, buf)
        bufAddUleb128(globalIdx, buf)
      },
      // Table Instructions
      WasmInstr_Table_Get(tableIdx) => {
        Buffer.addUint8(0x25us, buf)
        bufAddUleb128(tableIdx, buf)
      },
      WasmInstr_Table_Set(tableIdx) => {
        Buffer.addUint8(0x26us, buf)
        bufAddUleb128(tableIdx, buf)
      },
      WasmInstr_Table_Init(elemIdx1, tableIdx2) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(12, buf)
        bufAddUleb128(elemIdx1, buf)
        bufAddUleb128(tableIdx2, buf)
      },
      WasmInstr_Elem_Drop(elemIdx) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(13, buf)
        bufAddUleb128(elemIdx, buf)
      },
      WasmInstr_Table_Copy(tableIdx1, tableIdx2) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(14, buf)
        bufAddUleb128(tableIdx1, buf)
        bufAddUleb128(tableIdx2, buf)
      },
      WasmInstr_Table_Grow(tableIdx) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(15, buf)
        bufAddUleb128(tableIdx, buf)
      },
      WasmInstr_Table_Size(tableIdx) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(16, buf)
        bufAddUleb128(tableIdx, buf)
      },
      WasmInstr_Table_Fill(tableIdx) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(17, buf)
        bufAddUleb128(tableIdx, buf)
      },
      // Memory Instructions
      WasmInstr_I32_Load(memArg) => {
        Buffer.addUint8(0x28us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load(memArg) => {
        Buffer.addUint8(0x29us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_F32_Load(memArg) => {
        Buffer.addUint8(0x2Aus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_F64_Load(memArg) => {
        Buffer.addUint8(0x2Bus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Load8_S(memArg) => {
        Buffer.addUint8(0x2Cus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Load8_U(memArg) => {
        Buffer.addUint8(0x2Dus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Load16_S(memArg) => {
        Buffer.addUint8(0x2Eus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Load16_U(memArg) => {
        Buffer.addUint8(0x2Fus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load8_S(memArg) => {
        Buffer.addUint8(0x30us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load8_U(memArg) => {
        Buffer.addUint8(0x31us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load16_S(memArg) => {
        Buffer.addUint8(0x32us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load16_U(memArg) => {
        Buffer.addUint8(0x33us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load32_S(memArg) => {
        Buffer.addUint8(0x34us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Load32_U(memArg) => {
        Buffer.addUint8(0x35us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Store(memArg) => {
        Buffer.addUint8(0x36us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Store(memArg) => {
        Buffer.addUint8(0x37us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_F32_Store(memArg) => {
        Buffer.addUint8(0x38us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_F64_Store(memArg) => {
        Buffer.addUint8(0x39us, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Store8(memArg) => {
        Buffer.addUint8(0x3Aus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I32_Store16(memArg) => {
        Buffer.addUint8(0x3Bus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Store8(memArg) => {
        Buffer.addUint8(0x3Cus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Store16(memArg) => {
        Buffer.addUint8(0x3Dus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_I64_Store32(memArg) => {
        Buffer.addUint8(0x3Eus, buf)
        buildMemArg(memArg, buf)
      },
      WasmInstr_Memory_Size => {
        Buffer.addUint8(0x3Fus, buf)
        Buffer.addUint8(0x30us, buf)
      },
      WasmInstr_Memory_Grow => {
        Buffer.addUint8(0x40us, buf)
        Buffer.addUint8(0x30us, buf)
      },
      WasmInstr_Memory_Init(n) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(8, buf)
        bufAddUleb128(n, buf)
        Buffer.addUint8(0x00us, buf)
      },
      WasmInstr_Data_Drop(n) => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(9, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_Memory_Copy => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(10, buf)
        Buffer.addUint8(0x00us, buf)
        Buffer.addUint8(0x00us, buf)
      },
      WasmInstr_Memory_Fill => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(11, buf)
        Buffer.addUint8(0x00us, buf)
      },
      // Numeric Instructions
      WasmInstr_I32_Const(n) => {
        Buffer.addUint8(0x41us, buf)
        bufAddLeb128(n, buf)
      },
      WasmInstr_I64_Const(n) => {
        Buffer.addUint8(0x42us, buf)
        bufAddLeb128(n, buf)
      },
      WasmInstr_F32_Const(n) => {
        Buffer.addUint8(0x43us, buf)
        Buffer.addFloat32(Float32.fromNumber(n), buf)
      },
      WasmInstr_F64_Const(n) => {
        Buffer.addUint8(0x44us, buf)
        Buffer.addFloat64(Float64.fromNumber(n), buf)
      },
      WasmInstr_I32_Eqz => Buffer.addUint8(0x45us, buf),
      WasmInstr_I32_Eq => Buffer.addUint8(0x45us, buf),
      WasmInstr_I32_Ne => Buffer.addUint8(0x45us, buf),
      WasmInstr_I32_Lt_S => Buffer.addUint8(0x48us, buf),
      WasmInstr_I32_Lt_U => Buffer.addUint8(0x49us, buf),
      WasmInstr_I32_Gt_S => Buffer.addUint8(0x4Aus, buf),
      WasmInstr_I32_Gt_U => Buffer.addUint8(0x4Bus, buf),
      WasmInstr_I32_Le_S => Buffer.addUint8(0x4Cus, buf),
      WasmInstr_I32_Le_U => Buffer.addUint8(0x4Dus, buf),
      WasmInstr_I32_Ge_S => Buffer.addUint8(0x4Eus, buf),
      WasmInstr_I32_Ge_U => Buffer.addUint8(0x4Fus, buf),
      WasmInstr_I64_Eqz => Buffer.addUint8(0x50us, buf),
      WasmInstr_I64_Eq => Buffer.addUint8(0x51us, buf),
      WasmInstr_I64_Ne => Buffer.addUint8(0x52us, buf),
      WasmInstr_I64_Lt_S => Buffer.addUint8(0x53us, buf),
      WasmInstr_I64_Lt_U => Buffer.addUint8(0x54us, buf),
      WasmInstr_I64_Gt_S => Buffer.addUint8(0x55us, buf),
      WasmInstr_I64_Gt_U => Buffer.addUint8(0x56us, buf),
      WasmInstr_I64_Le_S => Buffer.addUint8(0x57us, buf),
      WasmInstr_I64_Le_U => Buffer.addUint8(0x58us, buf),
      WasmInstr_I64_Ge_S => Buffer.addUint8(0x59us, buf),
      WasmInstr_I64_Ge_U => Buffer.addUint8(0x5Aus, buf),
      WasmInstr_F32_Eq => Buffer.addUint8(0x5Bus, buf),
      WasmInstr_F32_Ne => Buffer.addUint8(0x5Cus, buf),
      WasmInstr_F32_Lt => Buffer.addUint8(0x5Dus, buf),
      WasmInstr_F32_Gt => Buffer.addUint8(0x5Eus, buf),
      WasmInstr_F32_Le => Buffer.addUint8(0x5Fus, buf),
      WasmInstr_F32_Ge => Buffer.addUint8(0x60us, buf),
      WasmInstr_F64_Eq => Buffer.addUint8(0x61us, buf),
      WasmInstr_F64_Ne => Buffer.addUint8(0x62us, buf),
      WasmInstr_F64_Lt => Buffer.addUint8(0x63us, buf),
      WasmInstr_F64_Gt => Buffer.addUint8(0x64us, buf),
      WasmInstr_F64_Le => Buffer.addUint8(0x65us, buf),
      WasmInstr_F64_Ge => Buffer.addUint8(0x66us, buf),
      WasmInstr_I32_Clz => Buffer.addUint8(0x67us, buf),
      WasmInstr_I32_Ctz => Buffer.addUint8(0x68us, buf),
      WasmInstr_I32_Popcnt => Buffer.addUint8(0x69us, buf),
      WasmInstr_I32_Add => Buffer.addUint8(0x6Aus, buf),
      WasmInstr_I32_Sub => Buffer.addUint8(0x6Bus, buf),
      WasmInstr_I32_Mul => Buffer.addUint8(0x6Cus, buf),
      WasmInstr_I32_Div_S => Buffer.addUint8(0x6Dus, buf),
      WasmInstr_I32_Div_U => Buffer.addUint8(0x6Eus, buf),
      WasmInstr_I32_Rem_S => Buffer.addUint8(0x6Fus, buf),
      WasmInstr_I32_Rem_U => Buffer.addUint8(0x70us, buf),
      WasmInstr_I32_And => Buffer.addUint8(0x71us, buf),
      WasmInstr_I32_Or => Buffer.addUint8(0x72us, buf),
      WasmInstr_I32_Xor => Buffer.addUint8(0x73us, buf),
      WasmInstr_I32_Shl => Buffer.addUint8(0x74us, buf),
      WasmInstr_I32_Shr_S => Buffer.addUint8(0x75us, buf),
      WasmInstr_I32_Shr_U => Buffer.addUint8(0x76us, buf),
      WasmInstr_I32_Rotl => Buffer.addUint8(0x77us, buf),
      WasmInstr_I32_Rotr => Buffer.addUint8(0x78us, buf),
      WasmInstr_I64_Clz => Buffer.addUint8(0x79us, buf),
      WasmInstr_I64_Ctz => Buffer.addUint8(0x7Aus, buf),
      WasmInstr_I64_Popcnt => Buffer.addUint8(0x7Bus, buf),
      WasmInstr_I64_Add => Buffer.addUint8(0x7Cus, buf),
      WasmInstr_I64_Sub => Buffer.addUint8(0x7Dus, buf),
      WasmInstr_I64_Mul => Buffer.addUint8(0x7Eus, buf),
      WasmInstr_I64_Div_S => Buffer.addUint8(0x7Fus, buf),
      WasmInstr_I64_Div_U => Buffer.addUint8(0x80us, buf),
      WasmInstr_I64_Rem_S => Buffer.addUint8(0x81us, buf),
      WasmInstr_I64_Rem_U => Buffer.addUint8(0x82us, buf),
      WasmInstr_I64_And => Buffer.addUint8(0x83us, buf),
      WasmInstr_I64_Or => Buffer.addUint8(0x84us, buf),
      WasmInstr_I64_Xor => Buffer.addUint8(0x85us, buf),
      WasmInstr_I64_Shl => Buffer.addUint8(0x86us, buf),
      WasmInstr_I64_Shr_S => Buffer.addUint8(0x87us, buf),
      WasmInstr_I64_Shr_U => Buffer.addUint8(0x88us, buf),
      WasmInstr_I64_Rotl => Buffer.addUint8(0x89us, buf),
      WasmInstr_I64_Rotr => Buffer.addUint8(0x8Aus, buf),
      WasmInstr_F32_Abs => Buffer.addUint8(0x8Bus, buf),
      WasmInstr_F32_Neg => Buffer.addUint8(0x8Cus, buf),
      WasmInstr_F32_Ceil => Buffer.addUint8(0x8Dus, buf),
      WasmInstr_F32_Floor => Buffer.addUint8(0x8Eus, buf),
      WasmInstr_F32_Trunc => Buffer.addUint8(0x8Fus, buf),
      WasmInstr_F32_Nearest => Buffer.addUint8(0x90us, buf),
      WasmInstr_F32_Sqrt => Buffer.addUint8(0x91us, buf),
      WasmInstr_F32_Add => Buffer.addUint8(0x92us, buf),
      WasmInstr_F32_Sub => Buffer.addUint8(0x93us, buf),
      WasmInstr_F32_Mul => Buffer.addUint8(0x94us, buf),
      WasmInstr_F32_Div => Buffer.addUint8(0x95us, buf),
      WasmInstr_F32_Min => Buffer.addUint8(0x96us, buf),
      WasmInstr_F32_Max => Buffer.addUint8(0x97us, buf),
      WasmInstr_F32_CopySign => Buffer.addUint8(0x98us, buf),
      WasmInstr_F64_Abs => Buffer.addUint8(0x99us, buf),
      WasmInstr_F64_Neg => Buffer.addUint8(0x9Aus, buf),
      WasmInstr_F64_Ceil => Buffer.addUint8(0x9Bus, buf),
      WasmInstr_F64_Floor => Buffer.addUint8(0x9Cus, buf),
      WasmInstr_F64_Trunc => Buffer.addUint8(0x9Dus, buf),
      WasmInstr_F64_Nearest => Buffer.addUint8(0x9Eus, buf),
      WasmInstr_F64_Sqrt => Buffer.addUint8(0x9Fus, buf),
      WasmInstr_F64_Add => Buffer.addUint8(0xA0us, buf),
      WasmInstr_F64_Sub => Buffer.addUint8(0xA1us, buf),
      WasmInstr_F64_Mul => Buffer.addUint8(0xA2us, buf),
      WasmInstr_F64_Div => Buffer.addUint8(0xA3us, buf),
      WasmInstr_F64_Min => Buffer.addUint8(0xA4us, buf),
      WasmInstr_F64_Max => Buffer.addUint8(0xA5us, buf),
      WasmInstr_F64_CopySign => Buffer.addUint8(0xA6us, buf),
      WasmInstr_I32_Wrap_I64 => Buffer.addUint8(0xA7us, buf),
      WasmInstr_I32_Trunc_F32_S => Buffer.addUint8(0xA8us, buf),
      WasmInstr_I32_Trunc_F32_U => Buffer.addUint8(0xA9us, buf),
      WasmInstr_I32_Trunc_F64_S => Buffer.addUint8(0xAAus, buf),
      WasmInstr_I32_Trunc_F64_U => Buffer.addUint8(0xABus, buf),
      WasmInstr_I64_Extend_I32_S => Buffer.addUint8(0xACus, buf),
      WasmInstr_I64_Extend_I32_U => Buffer.addUint8(0xADus, buf),
      WasmInstr_I64_Trunc_F32_S => Buffer.addUint8(0xAEus, buf),
      WasmInstr_I64_Trunc_F32_U => Buffer.addUint8(0xAFus, buf),
      WasmInstr_I64_Trunc_F64_S => Buffer.addUint8(0xB0us, buf),
      WasmInstr_I64_Trunc_F64_U => Buffer.addUint8(0xB1us, buf),
      WasmInstr_F32_Convert_I32_S => Buffer.addUint8(0xB2us, buf),
      WasmInstr_F32_Convert_I32_U => Buffer.addUint8(0xB3us, buf),
      WasmInstr_F32_Convert_I64_S => Buffer.addUint8(0xB4us, buf),
      WasmInstr_F32_Convert_I64_U => Buffer.addUint8(0xB5us, buf),
      WasmInstr_F32_Demote_F64 => Buffer.addUint8(0xB6us, buf),
      WasmInstr_F64_Convert_I32_S => Buffer.addUint8(0xB7us, buf),
      WasmInstr_F64_Convert_I32_U => Buffer.addUint8(0xB8us, buf),
      WasmInstr_F64_Convert_I64_S => Buffer.addUint8(0xB9us, buf),
      WasmInstr_F64_Convert_I64_U => Buffer.addUint8(0xBAus, buf),
      WasmInstr_F64_Promote_F32 => Buffer.addUint8(0xBBus, buf),
      WasmInstr_I32_Reinterpret_F32 => Buffer.addUint8(0xBCus, buf),
      WasmInstr_I64_Reinterpret_F64 => Buffer.addUint8(0xBDus, buf),
      WasmInstr_F32_Reinterpret_I32 => Buffer.addUint8(0xBEus, buf),
      WasmInstr_F64_Reinterpret_I64 => Buffer.addUint8(0xBFus, buf),
      WasmInstr_I32_Extend8_S => Buffer.addUint8(0xC0us, buf),
      WasmInstr_I32_Extend16_S => Buffer.addUint8(0xC1us, buf),
      WasmInstr_I64_Extend8_S => Buffer.addUint8(0xC2us, buf),
      WasmInstr_I64_Extend16_S => Buffer.addUint8(0xC3us, buf),
      WasmInstr_I64_Extend32_S => Buffer.addUint8(0xC4us, buf),
      WasmInstr_I32_TruncSat_F32_S => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(0, buf)
      },
      WasmInstr_I32_TruncSat_F32_U => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(1, buf)
      },
      WasmInstr_I32_TruncSat_F64_S => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(2, buf)
      },
      WasmInstr_I32_TruncSat_F64_U => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(3, buf)
      },
      WasmInstr_I64_TruncSat_F32_S => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(4, buf)
      },
      WasmInstr_I64_TruncSat_F32_U => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(5, buf)
      },
      WasmInstr_I64_TruncSat_F64_S => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(6, buf)
      },
      WasmInstr_I64_TruncSat_F64_U => {
        Buffer.addUint8(0xFCus, buf)
        bufAddUleb128(7, buf)
      },
      // Vector Instructions
      WasmInstr_V128_Load(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(0, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_8x8_Load_S(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(1, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_8x8_Load_U(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(2, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_16x4_Load_S(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(3, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_16x4_Load_U(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(4, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_32x2_Load_S(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(5, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_32x2_Load_U(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(6, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Load_8_Splat(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(7, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Load_16_Splat(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(8, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Load_32_Splat(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(9, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Load_64_Splat(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(10, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_Load_32_Zero(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(92, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_Load_64_Zero(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(93, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Store(memoryArg) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(11, buf)
        buildMemArg(memoryArg, buf)
      },
      WasmInstr_V128_Load8_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(84, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Load16_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(85, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Load32_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(86, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Load64_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(87, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Store8_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(88, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Store16_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(89, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Store32_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(90, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      WasmInstr_V128_Store64_Lane(memoryArg, laneIdx) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(91, buf)
        buildMemArg(memoryArg, buf)
        bufAddUleb128(laneIdx, buf)
      },
      // TODO: Validate this
      WasmInstr_V128_Const(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(12, buf)
        let lowerBits = Int64.fromNumber(n & 0xFFFFFFFF00000000)
        let upperBits = Int64.fromNumber(n & 0x00000000FFFFFFFF)
        Buffer.addInt64(lowerBits, buf)
        Buffer.addInt64(upperBits, buf)
      },
      // TODO: Validate this
      WasmInstr_I8x16_Shuffle(
        laneIdx1,
        laneIdx2,
        laneIdx3,
        laneIdx4,
        laneIdx5,
        laneIdx6,
        laneIdx7,
        laneIdx8,
        laneIdx9,
        laneIdx10,
        laneIdx11,
        laneIdx12,
        laneIdx13,
        laneIdx14,
        laneIdx15,
        laneIdx16
      ) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(13, buf)
        Buffer.addUint8(laneIdx1, buf)
        Buffer.addUint8(laneIdx2, buf)
        Buffer.addUint8(laneIdx3, buf)
        Buffer.addUint8(laneIdx4, buf)
        Buffer.addUint8(laneIdx5, buf)
        Buffer.addUint8(laneIdx6, buf)
        Buffer.addUint8(laneIdx7, buf)
        Buffer.addUint8(laneIdx8, buf)
        Buffer.addUint8(laneIdx9, buf)
        Buffer.addUint8(laneIdx10, buf)
        Buffer.addUint8(laneIdx11, buf)
        Buffer.addUint8(laneIdx12, buf)
        Buffer.addUint8(laneIdx13, buf)
        Buffer.addUint8(laneIdx14, buf)
        Buffer.addUint8(laneIdx15, buf)
        Buffer.addUint8(laneIdx16, buf)
      },
      WasmInstr_I8x16_Extract_Lane_S(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(21, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I8x16_Extract_Lane_U(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(22, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I8x16_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(23, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I16x8_Extract_Lane_S(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(24, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I16x8_Extract_Lane_U(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(25, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I16x8_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(26, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I32x4_Extract_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(27, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I32x4_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(28, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I64x2_Extract_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(29, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I64x2_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(30, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_F32x4_Extract_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(31, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_F32x4_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(32, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_F64x2_Extract_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(33, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_F64x2_Replace_Lane(n) => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(34, buf)
        bufAddUleb128(n, buf)
      },
      WasmInstr_I8x16_Swizzle => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(14, buf)
      },
      WasmInstr_I8x16_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(15, buf)
      },
      WasmInstr_I16x8_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(16, buf)
      },
      WasmInstr_I32x4_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(17, buf)
      },
      WasmInstr_I64x2_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(18, buf)
      },
      WasmInstr_F32x4_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(19, buf)
      },
      WasmInstr_F64x2_Splat => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(20, buf)
      },
      WasmInstr_I8x16_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(35, buf)
      },
      WasmInstr_I8x16_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(36, buf)
      },
      WasmInstr_I8x16_Lt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(37, buf)
      },
      WasmInstr_I8x16_Lt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(38, buf)
      },
      WasmInstr_I8x16_Gt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(39, buf)
      },
      WasmInstr_I8x16_Gt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(40, buf)
      },
      WasmInstr_I8x16_Le_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(41, buf)
      },
      WasmInstr_I8x16_Le_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(42, buf)
      },
      WasmInstr_I8x16_Ge_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(43, buf)
      },
      WasmInstr_I8x16_Ge_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(44, buf)
      },
      WasmInstr_I16x8_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(45, buf)
      },
      WasmInstr_I16x8_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(46, buf)
      },
      WasmInstr_I16x8_Lt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(47, buf)
      },
      WasmInstr_I16x8_Lt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(48, buf)
      },
      WasmInstr_I16x8_Gt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(49, buf)
      },
      WasmInstr_I16x8_Gt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(50, buf)
      },
      WasmInstr_I16x8_Le_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(51, buf)
      },
      WasmInstr_I16x8_Le_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(52, buf)
      },
      WasmInstr_I16x8_Ge_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(53, buf)
      },
      WasmInstr_I16x8_Ge_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(54, buf)
      },
      WasmInstr_I32x4_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(55, buf)
      },
      WasmInstr_I32x4_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(56, buf)
      },
      WasmInstr_I32x4_Lt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(57, buf)
      },
      WasmInstr_I32x4_Lt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(58, buf)
      },
      WasmInstr_I32x4_Gt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(59, buf)
      },
      WasmInstr_I32x4_Gt_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(60, buf)
      },
      WasmInstr_I32x4_Le_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(61, buf)
      },
      WasmInstr_I32x4_Le_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(62, buf)
      },
      WasmInstr_I32x4_Ge_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(63, buf)
      },
      WasmInstr_I32x4_Ge_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(64, buf)
      },
      WasmInstr_I64x2_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(214, buf)
      },
      WasmInstr_I64x2_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(215, buf)
      },
      WasmInstr_I64x2_Lt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(216, buf)
      },
      WasmInstr_I64x2_Gt_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(217, buf)
      },
      WasmInstr_I64x2_Le_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(218, buf)
      },
      WasmInstr_I64x2_Ge_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(219, buf)
      },
      WasmInstr_F32x4_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(65, buf)
      },
      WasmInstr_F32x4_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(66, buf)
      },
      WasmInstr_F32x4_Lt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(67, buf)
      },
      WasmInstr_F32x4_Gt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(68, buf)
      },
      WasmInstr_F32x4_Le => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(69, buf)
      },
      WasmInstr_F32x4_Ge => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(70, buf)
      },
      WasmInstr_F64x2_Eq => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(71, buf)
      },
      WasmInstr_F64x2_Ne => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(72, buf)
      },
      WasmInstr_F64x2_Lt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(73, buf)
      },
      WasmInstr_F64x2_Gt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(74, buf)
      },
      WasmInstr_F64x2_Le => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(75, buf)
      },
      WasmInstr_F64x2_Ge => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(76, buf)
      },
      WasmInstr_V128_Not => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(77, buf)
      },
      WasmInstr_V128_And => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(78, buf)
      },
      WasmInstr_V128_And_Not => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(79, buf)
      },
      WasmInstr_V128_Or => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(80, buf)
      },
      WasmInstr_V128_Xor => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(81, buf)
      },
      WasmInstr_V128_Bitselect => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(82, buf)
      },
      WasmInstr_V128_Any_True => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(83, buf)
      },
      WasmInstr_I8x16_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(96, buf)
      },
      WasmInstr_I8x16_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(97, buf)
      },
      WasmInstr_I8x16_Popcnt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(98, buf)
      },
      WasmInstr_I8x16_All_True => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(99, buf)
      },
      WasmInstr_I8x16_Bitmask => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(100, buf)
      },
      WasmInstr_I8x16_Narrow_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(101, buf)
      },
      WasmInstr_I8x16_Narrow_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(102, buf)
      },
      WasmInstr_I8x16_Shl => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(107, buf)
      },
      WasmInstr_I8x16_Shr_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(108, buf)
      },
      WasmInstr_I8x16_Shr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(109, buf)
      },
      WasmInstr_I8x16_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(110, buf)
      },
      WasmInstr_I8x16_Add_Sat_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(111, buf)
      },
      WasmInstr_I8x16_Add_Sat_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(112, buf)
      },
      WasmInstr_I8x16_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(113, buf)
      },
      WasmInstr_I8x16_Sub_Sat_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(114, buf)
      },
      WasmInstr_I8x16_Sub_Sat_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(115, buf)
      },
      WasmInstr_I8x16_Min_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(118, buf)
      },
      WasmInstr_I8x16_Min_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(119, buf)
      },
      WasmInstr_I8x16_Max_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(120, buf)
      },
      WasmInstr_I8x16_Max_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(121, buf)
      },
      WasmInstr_I8x16_Avgr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(123, buf)
      },
      WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(124, buf)
      },
      WasmInstr_I16x8_ExtAdd_Pairwise_I8x16_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(125, buf)
      },
      WasmInstr_I16x8_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(128, buf)
      },
      WasmInstr_I16x8_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(129, buf)
      },
      WasmInstr_I16x8_q15mulr_sat_s => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(130, buf)
      },
      WasmInstr_I16x8_All_True => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(131, buf)
      },
      WasmInstr_I16x8_Bitmask => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(132, buf)
      },
      WasmInstr_I16x8_Narrow_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(133, buf)
      },
      WasmInstr_I16x8_Narrow_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(134, buf)
      },
      WasmInstr_I16x8_Extend_Low_I8x16_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(135, buf)
      },
      WasmInstr_I16x8_Extend_High_I8x16_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(136, buf)
      },
      WasmInstr_I16x8_Extend_Low_I8x16_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(137, buf)
      },
      WasmInstr_I16x8_Extend_High_I8x16_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(138, buf)
      },
      WasmInstr_I16x8_Shl => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(139, buf)
      },
      WasmInstr_I16x8_Shr_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(140, buf)
      },
      WasmInstr_I16x8_Shr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(141, buf)
      },
      WasmInstr_I16x8_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(142, buf)
      },
      WasmInstr_I16x8_Add_Sat_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(143, buf)
      },
      WasmInstr_I16x8_Add_Sat_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(144, buf)
      },
      WasmInstr_I16x8_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(145, buf)
      },
      WasmInstr_I16x8_Sub_Sat_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(146, buf)
      },
      WasmInstr_I16x8_Sub_Sat_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(147, buf)
      },
      WasmInstr_I16x8_Mul => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(149, buf)
      },
      WasmInstr_I16x8_Min_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(150, buf)
      },
      WasmInstr_I16x8_Min_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(151, buf)
      },
      WasmInstr_I16x8_Max_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(152, buf)
      },
      WasmInstr_I16x8_Max_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(153, buf)
      },
      WasmInstr_I16x8_Avgr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(155, buf)
      },
      WasmInstr_I16x8_ExtMulLow_I8x16_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(156, buf)
      },
      WasmInstr_I16x8_ExtMulHigh_I8x16_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(157, buf)
      },
      WasmInstr_I16x8_ExtMulLow_I8x16_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(158, buf)
      },
      WasmInstr_I16x8_ExtMulHigh_I8x16_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(159, buf)
      },
      WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(126, buf)
      },
      WasmInstr_I32x4_ExtAdd_Pairwise_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(127, buf)
      },
      WasmInstr_I32x4_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(160, buf)
      },
      WasmInstr_I32x4_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(161, buf)
      },
      WasmInstr_I32x4_All_True => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(163, buf)
      },
      WasmInstr_I32x4_Bitmask => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(164, buf)
      },
      WasmInstr_I32x4_Extend_Low_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(167, buf)
      },
      WasmInstr_I32x4_Extend_High_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(168, buf)
      },
      WasmInstr_I32x4_Extend_Low_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(169, buf)
      },
      WasmInstr_I32x4_Extend_High_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(170, buf)
      },
      WasmInstr_I32x4_Shl => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(171, buf)
      },
      WasmInstr_I32x4_Shr_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(172, buf)
      },
      WasmInstr_I32x4_Shr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(173, buf)
      },
      WasmInstr_I32x4_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(174, buf)
      },
      WasmInstr_I32x4_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(177, buf)
      },
      WasmInstr_I32x4_Mul => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(181, buf)
      },
      WasmInstr_I32x4_Min_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(182, buf)
      },
      WasmInstr_I32x4_Min_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(183, buf)
      },
      WasmInstr_I32x4_Max_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(184, buf)
      },
      WasmInstr_I32x4_Max_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(185, buf)
      },
      WasmInstr_I32x4_Dot_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(186, buf)
      },
      WasmInstr_I32x4_ExtMulLow_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(188, buf)
      },
      WasmInstr_I32x4_ExtMulHigh_I16x8_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(189, buf)
      },
      WasmInstr_I32x4_ExtMulLow_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(190, buf)
      },
      WasmInstr_I32x4_ExtMulHigh_I16x8_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(191, buf)
      },
      WasmInstr_I64x2_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(192, buf)
      },
      WasmInstr_I64x2_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(193, buf)
      },
      WasmInstr_I64x2_All_True => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(195, buf)
      },
      WasmInstr_I64x2_Bitmask => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(196, buf)
      },
      WasmInstr_I64x2_Extend_Low_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(199, buf)
      },
      WasmInstr_I64x2_Extend_High_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(200, buf)
      },
      WasmInstr_I64x2_Extend_Low_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(201, buf)
      },
      WasmInstr_I64x2_Extend_High_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(202, buf)
      },
      WasmInstr_I64x2_Shl => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(203, buf)
      },
      WasmInstr_I64x2_Shr_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(204, buf)
      },
      WasmInstr_I64x2_Shr_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(205, buf)
      },
      WasmInstr_I64x2_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(206, buf)
      },
      WasmInstr_I64x2_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(209, buf)
      },
      WasmInstr_I64x2_Mul => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(213, buf)
      },
      WasmInstr_I64x2_ExtMulLow_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(220, buf)
      },
      WasmInstr_I64x2_ExtMulHigh_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(221, buf)
      },
      WasmInstr_I64x2_ExtMulLow_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(222, buf)
      },
      WasmInstr_I64x2_ExtMulHigh_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(223, buf)
      },
      WasmInstr_F32x4_Ceil => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(103, buf)
      },
      WasmInstr_F32x4_Floor => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(104, buf)
      },
      WasmInstr_F32x4_Trunc => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(105, buf)
      },
      WasmInstr_F32x4_Nearest => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(106, buf)
      },
      WasmInstr_F32x4_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(224, buf)
      },
      WasmInstr_F32x4_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(225, buf)
      },
      WasmInstr_F32x4_Sqrt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(227, buf)
      },
      WasmInstr_F32x4_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(228, buf)
      },
      WasmInstr_F32x4_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(229, buf)
      },
      WasmInstr_F32x4_Mul => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(230, buf)
      },
      WasmInstr_F32x4_Div => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(231, buf)
      },
      WasmInstr_F32x4_Min => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(232, buf)
      },
      WasmInstr_F32x4_Max => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(233, buf)
      },
      WasmInstr_F32x4_Pmin => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(234, buf)
      },
      WasmInstr_F32x4_Pmax => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(235, buf)
      },
      WasmInstr_F64x2_Ceil => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(216, buf)
      },
      WasmInstr_F64x2_Floor => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(217, buf)
      },
      WasmInstr_F64x2_Trunc => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(222, buf)
      },
      WasmInstr_F64x2_Nearest => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(248, buf)
      },
      WasmInstr_F64x2_Abs => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(236, buf)
      },
      WasmInstr_F64x2_Neg => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(237, buf)
      },
      WasmInstr_F64x2_Sqrt => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(239, buf)
      },
      WasmInstr_F64x2_Add => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(240, buf)
      },
      WasmInstr_F64x2_Sub => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(241, buf)
      },
      WasmInstr_F64x2_Mul => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(242, buf)
      },
      WasmInstr_F64x2_Div => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(243, buf)
      },
      WasmInstr_F64x2_Min => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(244, buf)
      },
      WasmInstr_F64x2_Max => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(245, buf)
      },
      WasmInstr_F64x2_Pmin => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(246, buf)
      },
      WasmInstr_F64x2_Pmax => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(247, buf)
      },
      WasmInstr_I32x4_Trunc_Sat_F32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(248, buf)
      },
      WasmInstr_I32x4_Trunc_Sat_F32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(249, buf)
      },
      WasmInstr_F32x4_Convert_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(250, buf)
      },
      WasmInstr_F32x4_Convert_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(251, buf)
      },
      WasmInstr_I32x4_Trunc_Sat_F64x2_S_Zero => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(252, buf)
      },
      WasmInstr_I32x4_Trunc_Sat_F64x2_U_Zero => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(253, buf)
      },
      WasmInstr_F64x2_ConvertLow_I32x4_S => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(254, buf)
      },
      WasmInstr_F64x2_ConvertLow_I32x4_U => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(255, buf)
      },
      WasmInstr_F32x4_Demote_F64x2_Zero => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(94, buf)
      },
      WasmInstr_F64x2_PromoteLow_F32x4 => {
        Buffer.addUint8(0xFDus, buf)
        bufAddUleb128(295, buf)
      },
      // End
      // TODO: Realistically you should never be able to get an else instr we need to get rid of this instruction code
      WasmInstr_Else => Buffer.addUint8(0x05us, buf),
      WasmInstr_End => Buffer.addUint8(0x0Bus, buf),
    }
    return None
  }
  and buildExpr = (expr, buf) => {
    // TODO: Refactor this to take advantage of tail calls
    let mut err = None
    // TODO: Consider using Some to stop when we find an error instantly
    List.forEach(instr => {
      if (err != None) return
      err = buildInstr(instr, buf)
      return
    }, expr)
    err
  }

  // Build Each Section
  let buildCustomSection = (bytes: Bytes) => Ok(RawCustomSection(bytes))
  let buildTypeSection = (wasmTypes: List<WasmType>) => {
    let buf = Buffer.make(0)
    // Add Type Count
    bufAddUleb128(List.length(wasmTypes), buf)
    // Go Through Types
    let mut err = None
    List.forEach(wasmType => {
      if (err != None) return
      // Compile The Type
      match (wasmType) {
        WasmFuncType(params, returns) => {
          // Add Func Type ID
          Buffer.addUint8(0x60us, buf)
          // Compile Params
          bufAddUleb128(List.length(params), buf)
          List.forEach(param => {
            match (param) {
              // TODO: Break this into a compile WasmType
              WasmI32 => Buffer.addUint8(0x7Fus, buf),
              WasmI64 => Buffer.addUint8(0x7Eus, buf),
              WasmF32 => Buffer.addUint8(0x7Dus, buf),
              WasmF64 => Buffer.addUint8(0x7Cus, buf),
              _ => err = Some(Err(InvalidTypeInFunction)),
            }
          }, params)
          // Compile Returns
          bufAddUleb128(List.length(returns), buf)
          List.forEach(ret => {
            match (ret) {
              WasmI32 => Buffer.addUint8(0x7Fus, buf),
              WasmI64 => Buffer.addUint8(0x7Eus, buf),
              WasmF32 => Buffer.addUint8(0x7Dus, buf),
              WasmF64 => Buffer.addUint8(0x7Cus, buf),
              _ => err = Some(Err(InvalidTypeInFunction)),
            }
          }, returns)
        },
        _ => err = Some(Err(InvalidTypeInTypeSection)),
      }
      return
    }, wasmTypes)
    // Return output
    match (err) {
      Some(e) => e,
      None => Ok(RawTypeSection(Buffer.toBytes(buf))),
    }
  }
  let buildImportSection = (wasmImports: List<WasmImport>) => {
    let buf = Buffer.make(0)
    // Add Import Count
    bufAddUleb128(List.length(wasmImports), buf)
    // Compile The Imports
    let mut err = None
    List.forEach(wasmImport => {
      if (err != None) return
      // Compile The Import Name
      buffAddStr(wasmImport.importModName, buf)
      // Compile The Import Module Name
      buffAddStr(wasmImport.importName, buf)
      // Compile The Import Description
      match (wasmImport.importDesc) {
        WasmFuncImportDesc(funcIdx) => {
          // Add Import Desc ID
          Buffer.addUint8(0x00us, buf)
          // Add Func Index
          bufAddUleb128(funcIdx, buf)
        },
        WasmTableImportDesc(tableType) => {
          // Add Import Desc ID
          Buffer.addUint8(0x01us, buf)
          // Add Table Type Info
          match (tableType.wasmType) {
            // TODO: Break this into a compile WasmType
            WasmFuncRef => Buffer.addUint8(0x70us, buf),
            WasmExternRef => Buffer.addUint8(0x6Fus, buf),
            _ => {
              err = Some(Err(InvalidTableTypeImport))
              return
            },
          }
          // Add Table Limits
          buildLimit(tableType.minLimit, tableType.maxLimit, buf)
        },
        WasmMemoryImportDesc(minVal, maxVal) => {
          // Add Import Desc ID
          Buffer.addUint8(0x02us, buf)
          // Add Memory Limits
          buildLimit(minVal, maxVal, buf)
        },
        WasmGlobalImportDesc(globalType) => {
          // Add Import Desc ID
          Buffer.addUint8(0x03us, buf)
          // Compile Global Info
          match (buildWasmGlobal(globalType, buf)) {
            Some(e) => {
              err = Some(Err(e))
              return
            },
            None => void,
          }
        },
      }
      return
    }, wasmImports)
    // Return The Output
    match (err) {
      Some(e) => e,
      None => Ok(RawImportSection(Buffer.toBytes(buf))),
    }
  }
  let buildFunctionSection = (funcs: List<Number>) => {
    let buf = Buffer.make(0)
    // Add Function Count
    bufAddUleb128(List.length(funcs), buf)
    // Compile Each Function
    List.forEach(func => {
      // Add Function Index
      bufAddUleb128(func, buf)
    }, funcs)
    // Return The Output
    Ok(RawFunctionSection(Buffer.toBytes(buf)))
  }
  let buildTableSection = (tables: List<WasmTableType>) => {
    let buf = Buffer.make(0)
    // Add Table Count
    bufAddUleb128(List.length(tables), buf)
    // Compile Each Table
    let mut err = None
    List.forEach((table: WasmTableType) => {
      if (err != None) return
      // Add Table Type Info
      match (table.wasmType) {
        // TODO: Break this into a compile WasmType
        WasmFuncRef => Buffer.addUint8(0x70us, buf),
        WasmExternRef => Buffer.addUint8(0x6Fus, buf),
        _ => {
          err = Some(Err(InvalidTableTypeImport))
          return
        },
      }
      // Add Table Limits
      buildLimit(table.minLimit, table.maxLimit, buf)
      return
    }, tables)
    // Return The Output
    match (err) {
      Some(e) => e,
      None => Ok(RawTableSection(Buffer.toBytes(buf))),
    }
  }
  let buildMemorySection = (mems: List<(Number, Option<Number>)>) => {
    let buf = Buffer.make(0)
    // Add Mem Count
    bufAddUleb128(List.length(mems), buf)
    // Compile Each Memory
    List.forEach(((minLimit, maxLimit)) => {
      buildLimit(minLimit, maxLimit, buf)
    }, mems)
    // Return
    Ok(RawMemorySection(Buffer.toBytes(buf)))
  }
  let buildGlobalSection = (globals: List<(WasmGlobalType, Expression)>) => {
    let buf = Buffer.make(0)
    // Add Global Count
    bufAddUleb128(List.length(globals), buf)
    // Compile Each Global
    let mut err = None
    List.forEach(((globalType, globalInit)) => {
      if (err != None) return
      // Compile Global Type
      match (buildWasmGlobal(globalType, buf)) {
        Some(e) => {
          err = Some(Err(e))
          return
        },
        None => void,
      }
      // Compile Global Init
      match (buildExpr(globalInit, buf)) {
        Some(e) => {
          err = Some(Err(e))
          return
        },
        None => void,
      }
      return
    }, globals)
    // Return
    match (err) {
      Some(e) => e,
      None => Ok(RawGlobalSection(Buffer.toBytes(buf))),
    }
  }
  // TODO: Implement this
  let buildExportSection = (exports: List<WasmExportType>) =>
    Ok(RawExportSection(Bytes.make(0)))
  let buildStartSection = (startFunc: Number) => {
    let buf = Buffer.make(0)
    // Add Our StartFunc idx
    bufAddUleb128(startFunc, buf)
    // Return
    Ok(RawStartSection(Buffer.toBytes(buf)))
  }
  // TODO: Implement this
  let buildElementSection = (elements: List<WasmElementSegment>) =>
    Ok(RawElementSection(Bytes.make(0)))
  // TODO: Implement this
  let buildDataCountSection = (dataCount: Number) =>
    Ok(RawDataCountSection(Bytes.make(0)))
  // TODO: Implement this
  let buildCodeSection = (funcs: List<WasmFunctionType>) => {
    let buf = Buffer.make(0)
    // Add Code Count
    bufAddUleb128(List.length(funcs), buf)
    // For Each Code
    let mut err = None
    List.forEach(func => {
      if (err != None) return
      // Add Local Info
      bufAddUleb128(List.length(func.locals), buf)
      List.forEach(local => {
        if (err != None) return
        bufAddUleb128(local.count, buf)
        match (local.wasmType) {
          // TODO: Break this into a compile WasmType
          WasmI32 => Buffer.addUint8(0x7Fus, buf),
          WasmI64 => Buffer.addUint8(0x7Eus, buf),
          WasmF32 => Buffer.addUint8(0x7Dus, buf),
          WasmF64 => Buffer.addUint8(0x7Cus, buf),
          _ => err = Some(InvalidTypeInFunction),
        }
        return
      }, func.locals)
      if (err != None) return
      // Add Code Info
      match (buildExpr(func.body, buf)) {
        Some(e) => {
          err = Some(e)
          return
        },
        None => void,
      }
      return
    }, funcs)
    // Return
    match (err) {
      Some(e) => Err(e),
      None => Ok(RawCodeSection(Buffer.toBytes(buf))),
    }
  }
  // TODO: Implement this
  let buildDataSection = (dataElems: List<WasmDataSegment>) =>
    Ok(RawDataSection(Bytes.make(0)))

  /**
   * Compiles a Wasm Section.
   *
   * @param section: The sections to compile
   *
   * @returns The compiled section
   */

  provide let buildSection = (section: Sections) => {
    match (section) {
      CustomSection(b) => buildCustomSection(b),
      TypeSection(types) => buildTypeSection(types),
      ImportSection(imports) => buildImportSection(imports),
      FunctionSection(funcs) => buildFunctionSection(funcs),
      TableSection(tables) => buildTableSection(tables),
      MemorySection(mems) => buildMemorySection(mems),
      GlobalSection(globals) => buildGlobalSection(globals),
      ExportSection(exports) => buildExportSection(exports),
      StartSection(startFunc) => buildStartSection(startFunc),
      ElementSection(elements) => buildElementSection(elements),
      DataCountSection(count) => buildDataCountSection(count),
      CodeSection(funcs) => buildCodeSection(funcs),
      DataSection(dataElems) => buildDataSection(dataElems),
    }
  }

  /**
   * Compiles Wasm Sections.
   *
   * @param sections: The sections to compile
   *
   * @returns The compiled sections
   */

  provide let buildSections = (sections: List<Sections>) => {
    // Compile Sections
    let compiledSections = List.map((section: Sections) =>
      buildSection(section), sections)
    // Check For Err's
    let mut err = None
    let verifiedSections = List.map(section => {
      if (err != None) return RawCustomSection(Bytes.make(0))
      match (section) {
        Ok(section) => return section,
        Err(e) => {
          // Set The Err
          err = Some(e)
          // Return A Dummy Section
          return RawCustomSection(Bytes.make(0))
        },
      }
    }, compiledSections)
    // Handle Return
    match (err) {
      Some(e) => Err(e),
      None => Ok(verifiedSections),
    }
  }

  /**
   * Bundles a wasm module.
   *
   * @param sections: The compiled sections to bundle
   *
   * @returns The bundled module
   */

  provide let buildModule = (sections: List<RawSections>) => {
    let wasmFile = Buffer.make(0)
    // Append Wasm Magic Number
    // TODO: Merge this into either an int32 or a string
    Buffer.addUint8(0x00us, wasmFile)
    Buffer.addUint8(0x61us, wasmFile)
    Buffer.addUint8(0x73us, wasmFile)
    Buffer.addUint8(0x6dus, wasmFile)
    // Append Wasm Version Number
    // TODO: Merge this into either an int32 or a string
    Buffer.addUint8(0x01us, wasmFile)
    Buffer.addUint8(0x00us, wasmFile)
    Buffer.addUint8(0x00us, wasmFile)
    Buffer.addUint8(0x00us, wasmFile)
    // Build Sections
    List.forEach(section => {
      match (section) {
        RawCustomSection(bytes) => buildRawSection(0x00us, bytes, wasmFile),
        RawTypeSection(bytes) => buildRawSection(0x01us, bytes, wasmFile),
        RawImportSection(bytes) => buildRawSection(0x02us, bytes, wasmFile),
        RawFunctionSection(bytes) => buildRawSection(0x03us, bytes, wasmFile),
        RawTableSection(bytes) => buildRawSection(0x04us, bytes, wasmFile),
        RawMemorySection(bytes) => buildRawSection(0x05us, bytes, wasmFile),
        RawGlobalSection(bytes) => buildRawSection(0x06us, bytes, wasmFile),
        RawExportSection(bytes) => buildRawSection(0x07us, bytes, wasmFile),
        RawStartSection(bytes) => buildRawSection(0x08us, bytes, wasmFile),
        RawElementSection(bytes) => buildRawSection(0x09us, bytes, wasmFile),
        RawDataCountSection(bytes) => buildRawSection(0x0cus, bytes, wasmFile),
        RawCodeSection(bytes) => buildRawSection(0x0aus, bytes, wasmFile),
        RawDataSection(bytes) => buildRawSection(0x0bus, bytes, wasmFile),
      }
    }, sections)
    return Buffer.toBytes(wasmFile)
  }
}
// TODO: Validator
// TODO: Optimizer
